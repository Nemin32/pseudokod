1.1. Algoritmus Euklideszi algoritmus
Bemenet: m − egész, n − egész
Kimenet: n − egész
1: függvény LNKO(m : egész, n : egész)
2: r ← m mod n
3: ciklus amíg r 6 = 0
4: m ← n
5: n ← r
6: r ← m mod n
7: ciklus vége
8: vissza n
9: függvény vége

1.2. Algoritmus Euklideszi algoritmus (2)
Bemenet: m − egész, n − egész
Kimenet: n − egész
1: eljárás LNKO(m : egész, címszerint n : egész)
2: r ← m mod n
3: ciklus amíg r 6 = 0
4: m ← n
5: n ← r
6: r ← m mod n
7: ciklus vége
8: eljárás vége

1.3. Algoritmus Relatív prím vizsgálat
Bemenet: x − egész tömb, n − egész (tömb mérete), érték − egész
Kimenet: y − logikai tömb
1: függvény RelatívPrímVizsgálat(x : egész tömb, n : egész, érték : egész)
2: y ← Létrehoz(logikai)[n]
3: ciklus i ← 1-től n-ig
4: ha LNKO(x[i], érték) = 1 akkor
5: y[i] ← igaz
6: különben
7: y[i] ← hamis
8: elágazás vége
9: ciklus vége
10: vissza y
11: függvény vége

1.4. Algoritmus Nullát eredményező elempárok száma
Bemenet: x − egész tömb, n − egész
Kimenet: db − egész
1: függvény NullátAdóElempárokSzáma(x : egész tömb, n : egész)
2: db ← 0
3: ciklus i ← 1-től (n − 1)-ig
4: ciklus j ← (i + 1)-től n-ig
5: ha x[i] + x[j] = 0 akkor
6: db ← db + 1
7: elágazás vége
8: ciklus vége
9: ciklus vége
10: vissza db
11: függvény vége

2.1. Algoritmus Sorozatszámítás programozási tétel
Bemenet: x − T tömb, n − egész (tömb mérete)
Kimenet: érték − T
1: függvény Sorozatszámítás(x : T tömb, n : egész)
2: érték ← érték0
3: ciklus i ← 1-től n-ig
4: érték ← érték ⊕ x[i]
5: ciklus vége
6: vissza érték
7: függvény vége

2.2. Algoritmus Eldöntés programozási tétel
Bemenet: x − T tömb, n − egész (tömb mérete), P − logikai (tulajdonság)
Kimenet: van − logikai
1: függvény Eldöntés(x : T tömb, n : egész, P : logikai)
2: i ← 1
3: ciklus amíg (i ≤ n) ∧ ¬P (x[i])
4: i ← i + 1
5: ciklus vége
6: van ← (i ≤ n)
7: vissza van
8: függvény vége

2.3. Algoritmus Módosított eldöntés programozási tétel
Bemenet: x − T tömb, n − egész (tömb mérete), P − logikai (tulajdonság)
Kimenet: van − logikai
1: függvény Eldöntés_Minden(x : T tömb, n : egész, P : logikai)
2: i ← 1
3: ciklus amíg (i ≤ n) ∧ P (x[i])
4: i ← i + 1
5: ciklus vége
6: van ← (i > n)
7: vissza van
8: függvény vége

2.4. Algoritmus Prím teszt
Bemenet: N − egész (N ≥ 2)
Kimenet: prím − logikai
1: függvény PrímTeszt(N : egész)
2: i ← 2
3: ciklus amíg (i ≤ √N ) ∧ ¬Osztója(i, N )
4: i ← i + 1
5: ciklus vége
6: prím ← (i > √N )
7: vissza prím
8: függvény vége

2.5. Algoritmus Növekvő rendezettség vizsgálata
Bemenet: x − T tömb, n − egész; ahol T összehasonlítható
Kimenet: rendezett − logikai
1: függvény Rendezett_E(x : T tömb, n : egész)
2: i ← 1
3: ciklus amíg (i ≤ n − 1) ∧ (x[i] ≤ x[i + 1])
4: i ← i + 1
5: ciklus vége
6: rendezett ← (i > n − 1)
7: vissza rendezett
8: függvény vége

2.6. Algoritmus Kiválasztás programozási tétel
Bemenet: x − T tömb, n − egész, P − logikai
Kimenet: idx − egész
1: függvény Kiválasztás(x : T tömb, n : egész, P : logikai)
2: i ← 1
3: ciklus amíg ¬P (x[i])
4: i ← i + 1
5: ciklus vége
6: idx ← i
7: vissza idx
8: függvény vége

2.7. Algoritmus Lineáris keresés programozási tétel
Bemenet: x − T tömb, n − egész, P − logikai
Kimenet: van − logikai, idx − egész
1: függvény LineárisKeresés(x : T tömb, n : egész, P : logikai)
2: i ← 1
3: ciklus amíg (i ≤ n) ∧ ¬P (x[i])
4: i ← i + 1
5: ciklus vége
6: van ← (i ≤ n)
7: ha van akkor
8: idx ← i
9: vissza (van, idx)
10: különben
11: vissza van
12: elágazás vége
13: függvény vége

2.8. Algoritmus Lineáris keresés programozási tétel (konkrét érték keresése)
Bemenet: x − T tömb, n − egész, érték − T
Kimenet: van − logikai, idx − egész
1: függvény LineárisKeresés(x : T tömb, n : egész, érték : T)
2: i ← 1
3: ciklus amíg (i ≤ n) ∧ (x[i] 6 = érték)
4: i ← i + 1
5: ciklus vége
6: van ← (i ≤ n)
7: ha van akkor
8: idx ← i
9: vissza (van, idx)
10: különben
11: vissza van
12: elágazás vége
13: függvény vége

2.9. Algoritmus Megszámlálás programozási tétel
Bemenet: x − T tömb, n − egész (tömb mérete), P − logikai (tulajdonság)
Kimenet: db − egész (darabszám)
1: függvény Megszámlálás(x : T tömb, n : egész, P : logikai)
2: db ← 0
3: ciklus i ← 1-től n-ig
4: ha P (x[i]) akkor
5: db ← db + 1
6: elágazás vége
7: ciklus vége
8: vissza db
9: függvény vége

2.10. Algoritmus Maximumkiválasztás programozási tétel.
Bemenet: x − T tömb, n − egész (tömb mérete); ahol T összehasonlítható
Kimenet: max − egész
1: függvény Maximumkiválasztás(x : T tömb, n : egész)
2: max ← 1
3: ciklus i ← 2-től n-ig
4: ha x[i] > x[max] akkor
5: max ← i
6: elágazás vége
7: ciklus vége
8: vissza max
9: függvény vége

2.11. Algoritmus Másolás programozási tétel
Bemenet: x − T tömb, n − egész (tömb mérete), f − művelet
Kimenet: y − T tömb
1: függvény Másolás(x : T tömb, n : egész, f : művelet)
2: y ← Létrehoz(T)[n]
3: ciklus i ← 1-től n-ig
4: y[i] ← f (x[i])
5: ciklus vége
6: vissza y
7: függvény vége

2.12. Algoritmus Kiválogatás programozási tétel
Bemenet: x − T tömb, n − egész (tömb mérete), P − logikai
Kimenet: y − T tömb, db − egész
1: függvény Kiválogatás(x : T tömb, n : egész, P : logikai)
2: y ← Létrehoz(T)[n]
3: db ← 0
4: ciklus i ← 1-től n-ig
5: ha P (x[i]) akkor
6: db ← db + 1
7: y[db] ← x[i]
8: elágazás vége
9: ciklus vége
10: vissza (y, db)
11: függvény vége

2.13. Algoritmus Kiválogatás programozási tétel az eredeti tömbben
Bemenet: x − T tömb, n − egész (tömb mérete), P − logikai
Kimenet: x − T tömb, db − egész
1: függvény KiválogatásHelyben(címszerint x : T tömb, n : egész, P : logikai)
2: db ← 0
3: ciklus i ← 1-től n-ig
4: ha P (x[i]) akkor
5: db ← db + 1
6: x[db] ← x[i]
7: elágazás vége
8: ciklus vége
9: vissza db
10: függvény vége

2.14. Algoritmus Kiválogatás programozási tétel az eredeti tömbben az eredeti elemek megtartásával
Bemenet: x − T tömb, n − egész (tömb mérete), P − logikai
Kimenet: x − T tömb, db − egész
1: függvény Szétválogatás(címszerint x : T tömb, n : egész, P : logikai)
2: db ← 0
3: ciklus i ← 1-től n-ig
4: ha P (x[i]) akkor
5: db ← db + 1
6: x[db] ↔ x[i]
7: elágazás vége
8: ciklus vége
9: vissza db
10: függvény vége

2.15. Algoritmus Szétválogatás programozási tétel
Bemenet: x − T tömb, n − egész (tömb mérete), P − logikai
Kimenet: y1 − T tömb, db1 − egész, y2 − T tömb, db2 − egész
1: függvény Szétválogatás(x : T tömb, n : egész, P : logikai)
2: y1 ← Létrehoz(T)[n]
3: y2 ← Létrehoz(T)[n]
4: db1 ← 0
5: db2 ← 0
6: ciklus i ← 1-től n-ig
7: ha P (x[i]) akkor
8: db1 ← db1 + 1
9: y1[db1] ← x[i]
10: különben
11: db2 ← db2 + 1
12: y2[db2] ← x[i]
13: elágazás vége
14: ciklus vége
15: vissza(y1, db1, y2, db2)
16: függvény vége

2.16. Algoritmus Szétválogatás programozási tétel egyetlen új kimeneti tömbbe
Bemenet: x − T tömb, n − egész (tömb mérete), P − logikai
Kimenet: y − T tömb, db − egész
1: függvény Szétválogatás(x : T tömb, n : egész, P : logikai)
2: y ← Létrehoz(T)[n]
3: db ← 0
4: jobb ← n + 1
5: ciklus i ← 1-től n-ig
6: ha P (x[i]) akkor
7: db ← db + 1
8: y[db] ← x[i]
9: különben
10: jobb ← jobb − 1
11: y[jobb] ← x[i]
12: elágazás vége
13: ciklus vége
14: vissza(y, db)
15: függvény vége

2.17. Algoritmus Szétválogatás programozási tétel az eredeti tömbben
Bemenet: x − T tömb, n − egész (tömb mérete), P − logikai
Kimenet: x − T tömb, db − egész
1: függvény Szétválogat(címszerint x : T tömb, n : egész, P : logikai)
2: bal ← 1
3: jobb ← n
4: segéd ← x[1]
5: ciklus amíg bal < jobb
6: ciklus amíg (bal < jobb) ∧ ¬P (x[jobb])
7: jobb ← jobb − 1
8: ciklus vége
9: ha bal < jobb akkor
10: x[bal] ← x[jobb]
11: bal ← bal + 1
12: ciklus amíg (bal < jobb) ∧ P (x[bal])
13: bal ← bal + 1
14: ciklus vége
15: ha bal < jobb akkor
16: x[jobb] ← x[bal]
17: jobb ← jobb − 1
18: elágazás vége
19: elágazás vége
20: ciklus vége
21: x[bal] ← segéd
22: ha P (x[bal]) akkor
23: db ← bal
24: különben
25: db ← bal − 1
26: elágazás vége
27: vissza db
28: függvény vége

2.18. Algoritmus Metszet programozási tétel
Bemenet: x1 − T tömb, n1 − egész (tömb mérete), x2 − T tömb, n2 − egész (tömb mérete)
Kimenet: y − T tömb, db − egész
1: függvény Metszet(x1 : T tömb, n1 : egész, x2 : T tömb, n2 : egész)
2: y ← Létrehoz(T)[n1]
3: db ← 0
4: ciklus i ← 1-től n1-ig
5: j ← 1
6: ciklus amíg (j ≤ n2) ∧ (x1[i] 6 = x2[j])
7: j ← j + 1
8: ciklus vége
9: ha j ≤ n2 akkor
10: db ← db + 1
11: y[db] ← x1[i]
12: elágazás vége
13: ciklus vége
14: vissza (y, db)
15: függvény vége

2.19. Algoritmus Közös elem létezésének vizsgálata
Bemenet: x1 − T tömb, n1 − egész (tömb mérete), x2 − T tömb, n2 − egész (tömb mérete)
Kimenet: van − logikai
1: függvény KözösElemEldöntése(x1 : T tömb, n1 : egész, x2 : T tömb, n2 : T tömb)
2: i ← 1
3: van ← hamis
4: ciklus amíg (i ≤ n1) ∧ ¬van
5: j ← 1
6: ciklus amíg (j ≤ n2) ∧ (x1[i] 6 = x2[j])
7: j ← j + 1
8: ciklus vége
9: ha j ≤ n2 akkor
10: van ← igaz
11: különben
12: i ← i + 1
13: elágazás vége
14: ciklus vége
15: vissza van
16: függvény vége

2.20. Algoritmus Unió programozási tétel
Bemenet: x1 − T tömb, n1 − egész (tömb mérete), x2 − T tömb, n2 − egész (tömb mérete)
Kimenet: y − T tömb, db − egész
1: függvény Unió(x1 : T tömb, n1 : egész, x2 : T tömb, n2 : egész)
2: y ← Létrehoz(T)[n1 + n2]
3: ciklus i ← 1-től n1-ig
4: y[i] ← x1[i]
5: ciklus vége
6: db ← n1
7: ciklus j ← 1-től n2-ig
8: i ← 1
9: ciklus amíg (i ≤ n1) ∧ (x1[i] 6 = x2[j])
10: i ← i + 1
11: ciklus vége
12: ha i > n1 akkor
13: db ← db + 1
14: y[db] ← x2[j]
15: elágazás vége
16: ciklus vége
17: vissza (y, db)
18: függvény vége

2.21. Algoritmus Ismétlődések kiszűrése
Bemenet: x − T tömb, n − egész (tömb mérete)
Kimenet: x − T tömb, db − egész
1: függvény IsmétlődésekKiszűrése(címszerint x : T tömb, n : egész)
2: db ← 1
3: ciklus i ← 2-től n-ig
4: j ← 1
5: ciklus amíg (j ≤ db) ∧ (x[i] 6 = x[j])
6: j ← j + 1
7: ciklus vége
8: ha j > db akkor
9: db ← db + 1
10: x[db] ← x[i]
11: elágazás vége
12: ciklus vége
13: vissza db
14: függvény vége

2.22. Algoritmus Összefuttatás programozási tétel
Bemenet: x1 − T rendezett tömb, n1 − egész (tömb mérete), x2 − T rendezett tömb, n2 −
egész (tömb mérete)
Kimenet: y − T rendezett tömb, db − egész
1: függvény Összefuttatás(x1 : T rendezett tömb, n1 : egész, x2 : T rendezett tömb, n2 :
egész)
2: y ← Létrehoz(T)[n1 + n2]
3: i ← 1
4: j ← 1
5: db ← 0
6: ciklus amíg (i ≤ n1) ∧ (j ≤ n2)
7: db ← db + 1
8: ha x1[i] < x2[j] akkor
9: y[db] ← x1[i]
10: i ← i + 1
11: különben
12: ha x1[i] > x2[j] akkor
13: y[db] ← x2[j]
14: j ← j + 1
15: különben
16: y[db] ← x1[i]
17: i ← i + 1
18: j ← j + 1
19: elágazás vége
20: elágazás vége
21: ciklus vége
22: ciklus amíg i ≤ n1
23: db ← db + 1
24: y[db] ← x1[i]
25: i ← i + 1
26: ciklus vége
27: ciklus amíg j ≤ n2
28: db ← db + 1
29: y[db] ← x2[j]
30: j ← j + 1
31: ciklus vége
32: vissza (y, db)
33: függvény vége

2.23. Algoritmus Módosított összefuttatás programozási tétel
Bemenet: x1 − T rendezett tömb, n1 − egész (tömb mérete), x2 − T rendezett tömb, n2 −
egész (tömb mérete)
Kimenet: y − T rendezett tömb, db − egész
1: függvény MódosítottÖsszefuttatás(x1 : T rendezett tömb, n1 : egész, x2 : T rendezett
tömb, n2 : egész)
2: y ← Létrehoz(T)[n1 + n2]
3: n1 ← n1 + 1
4: x1[n1] ← +∞
5: n2 ← n2 + 1
6: x2[n2] ← +∞
7: i ← 1
8: j ← 1
9: db ← 0
10: ciklus amíg (i < n1) ∨ (j < n2)
11: db ← db + 1
12: ha x1[i] < x2[j] akkor
13: y[db] ← x1[i]
14: i ← i + 1
15: különben ha x1[i] > x2[j] akkor
16: y[db] ← x2[j]
17: j ← j + 1
18: különben
19: y[db] ← x1[i]
20: i ← i + 1
21: j ← j + 1
22: elágazás vége
23: ciklus vége
24: vissza (y, db)
25: függvény vége

2.24. Algoritmus Másolás és sorozatszámítás összeépítése
Bemenet: x − T tömb, n − egész (tömb mérete), f − művelet
Kimenet: érték − T
1: függvény Másolás_Sorozatszámítás(x : T tömb, n : egész, f : művelet)
2: érték ← érték0
3: ciklus i ← 1-től n-ig
4: érték ← érték ⊕ f (x[i])
5: ciklus vége
6: vissza érték
7: függvény vége

2.25. Algoritmus Másolás és maximumkiválasztás összeépítése
Bemenet: x − T tömb, n − egész (tömb mérete), f − művelet; ahol T összehasonlítható
Kimenet: max − egész, maxérték − T
1: függvény Másolás_Maximumkiválasztás(x : T tömb, n : egész, f : művelet)
2: max ← 1
3: maxérték ← f (x[1])
4: ciklus i ← 2-től n-ig
5: segéd ← f (x[i])
6: ha maxérték < segéd akkor
7: max ← i
8: maxérték ← segéd
9: elágazás vége
10: ciklus vége
11: vissza (max, maxérték)
12: függvény vége

2.26. Algoritmus Másolás és maximumkiválasztás összeépítése (módosított, kevésbé hatékony változat)
Bemenet: x − T tömb, n − egész (tömb mérete), f − művelet; ahol T összehasonlítható
Kimenet: max − egész
1: függvény Másolás_Maximumkiválasztás_Módosított(x : T tömb, n : egész, f : művelet)
2: max ← 1
3: ciklus i ← 2-től n-ig
4: ha f (x[max]) < f (x[i]) akkor
5: max ← i
6: elágazás vége
7: ciklus vége
8: vissza max
9: függvény vége

2.27. Algoritmus Megszámolás és keresés összeépítése
Bemenet: x − T tömb, n − egész (tömb mérete), P − logikai, k − egész
Kimenet: van − logikai, idx − egész
1: függvény Megszámolás_Keresés(x : T tömb, n : egész, P : logikai, k : egész)
2: db ← 0
3: i ← 0
4: ciklus amíg (i < n) ∧ (db < k)
5: i ← i + 1
6: ha P (x[i]) akkor
7: db ← db + 1
8: elágazás vége
9: ciklus vége
10: van ← (db = k)
11: ha van akkor
12: idx ← i
13: vissza (van, idx)
14: különben
15: vissza van
16: elágazás vége
17: függvény vége

2.28. Algoritmus Maximumkiválasztás és kiválogatás összeépítése
Bemenet: x − T tömb, n − egész (tömb mérete); ahol T összehasonlítható
Kimenet: db − egész, y − egész tömb, maxérték − T
1: függvény Maximumkiválogatás(x : T tömb, n : egész)
2: y ← Létrehoz(egész)[n]
3: maxérték ← x[1]
4: db ← 1
5: y[db] ← 1
6: ciklus i ← 2-től n-ig
7: ha x[i] > maxérték akkor
8: maxérték ← x[i]
9: db ← 1
10: y[db] ← i
11: különben
12: ha x[i] = maxérték akkor
13: db ← db + 1
14: y[db] ← i
15: elágazás vége
16: elágazás vége
17: ciklus vége
18: vissza (db, y, maxérték)
19: függvény vége

2.29. Algoritmus Kiválogatás és sorozatszámítás összeépítése
Bemenet: x − T tömb, n − egész (tömb mérete), P − logikai
Kimenet: érték − T
1: függvény Kiválogatás_Sorozatszámítás(x : T tömb, n : egész, P : logikai)
2: érték ← érték0
3: ciklus i ← 1-től n-ig
4: ha P (x[i]) akkor
5: érték ← érték ⊕ x[i]
6: elágazás vége
7: ciklus vége
8: vissza érték
9: függvény vége

2.30. Algoritmus Kiválogatás és maximumkiválasztás összeépítése
Bemenet: x − T tömb, n − egész (tömb mérete), P − logikai; ahol T összehasonlítható
Kimenet: van − logikai, max − egész, maxérték − T
1: függvény Kiválogatás_Maximumkiválasztás(x : T tömb, n : egész, P : logikai)
2: maxérték ← −∞
3: ciklus i ← 1-től n-ig
4: ha P (x[i]) ∧ (x[i] > maxérték) akkor
5: max ← i
6: maxérték ← x[i]
7: elágazás vége
8: ciklus vége
9: van ← (maxérték > −∞)
10: ha van akkor
11: vissza (van, max, maxérték)
12: különben
13: vissza van
14: elágazás vége
15: függvény vége

2.31. Algoritmus Kiválogatás és másolás összeépítése
Bemenet: x − T tömb, n − egész (tömb mérete), P − logikai, f − művelet
Kimenet: db − egész, y − T tömb
1: függvény Kiválogatás_Másolás(x : T tömb, n : egész, P : logikai, f : művelet)
2: y ← Létrehoz(T)[n]
3: db ← 0
4: ciklus i ← 1-től n-ig
5: ha P (x[i]) akkor
6: db ← db + 1
7: y[db] ← f (x[i])
8: elágazás vége
9: ciklus vége
10: vissza (db, y)
11: függvény vége

3.1. Algoritmus Csere
Bemenet: a − T, b − T
Kimenet: a − T, b − T
1: eljárás Csere(címszerint a : T, címszerint b : T)
2: segéd ← a
3: a ← b
4: b ← segéd
5: eljárás vége

3.2. Algoritmus Egyszerű cserés rendezés
Bemenet: x − T tömb, n − egész (tömb mérete); ahol T összehasonlítható
Kimenet: x − T rendezett tömb
1: eljárás EgyszerűCserésRendezés(címszerint x : T tömb, n : egész)
2: ciklus i ← 1-től (n − 1)-ig
3: ciklus j ← (i + 1)-től n-ig
4: ha x[i] > x[j] akkor
5: x[i] ↔ x[j]
6: elágazás vége
7: ciklus vége
8: ciklus vége
9: eljárás vége

3.3. Algoritmus Minimumkiválasztásos rendezés
Bemenet: x − T tömb, n − egész (tömb mérete); ahol T összehasonlítható
Kimenet: x − T rendezett tömb
1: eljárás MinimumkiválasztásosRendezés(címszerint x : T tömb, n : egész)
2: ciklus i ← 1-től (n − 1)-ig
3: min ← i
4: ciklus j ← (i + 1)-től n-ig
5: ha x[min] > x[j] akkor
6: min ← j
7: elágazás vége
8: ciklus vége
9: x[i] ↔ x[min]
10: ciklus vége
11: eljárás vége

3.4. Algoritmus Buborékrendezés
Bemenet: x − T tömb, n − egész (tömb mérete); ahol T összehasonlítható
Kimenet: x − T rendezett tömb
1: eljárás BuborékRendezés(címszerint x : T tömb, n : egész)
2: ciklus i ← n-től 2-ig
3: ciklus j ← 1-től (i − 1)-ig
4: ha x[j] > x[j + 1] akkor
5: x[j] ↔ x[j + 1]
6: elágazás vége
7: ciklus vége
8: ciklus vége
9: eljárás vége

3.5. Algoritmus Javított buborékrendezés
Bemenet: x − T tömb, n − egész (tömb mérete); ahol T összehasonlítható
Kimenet: x − T rendezett tömb
1: eljárás JavítottBuborékRendezés(címszerint x : T tömb, n : egész)
2: i ← n
3: ciklus amíg i ≥ 2
4: idx ← 0
5: ciklus j ← 1-től (i − 1)-ig
6: ha x[j] > x[j + 1] akkor
7: x[j] ↔ x[j + 1]
8: idx ← j
9: elágazás vége
10: ciklus vége
11: i ← idx
12: ciklus vége
13: eljárás vége

3.6. Algoritmus Beillesztéses rendezés
Bemenet: x − T tömb, n − egész (tömb mérete); ahol T összehasonlítható
Kimenet: x − T rendezett tömb
1: eljárás BeillesztésesRendezés(címszerint x : T tömb, n : egész)
2: ciklus i ← 2-től n-ig
3: j ← i − 1
4: ciklus amíg (j > 0) ∧ (x[j] > x[j + 1])
5: x[j] ↔ x[j + 1]
6: j ← j − 1
7: ciklus vége
8: ciklus vége
9: eljárás vége

3.7. Algoritmus Javított beillesztéses rendezés
Bemenet: x − T tömb, n − egész (tömb mérete); ahol T összehasonlítható
Kimenet: x − T rendezett tömb
1: eljárás JavítottBeillesztésesRendezés(címszerint x : T tömb, n : egész)
2: ciklus i ← 2-től n-ig
3: j ← i − 1
4: segéd ← x[i]
5: ciklus amíg (j > 0) ∧ (x[j] > segéd)
6: x[j + 1] ← x[j]
7: j ← j − 1
8: ciklus vége
9: x[j + 1] ← segéd
10: ciklus vége
11: eljárás vége

3.8. Algoritmus Shell rendezés
Bemenet: x − T tömb, n − egész (tömb mérete); ahol T összehasonlítható
Kimenet: x − T rendezett tömb
1: eljárás ShellRendezés(címszerint x : T tömb, n : egész)
2: d ← KezdetiTávolság(n)
3: ciklus amíg d ≥ 1
4: ciklus i ← (d + 1)-től n-ig
5: j ← i − d
6: segéd ← x[i]
7: ciklus amíg (j > 0) ∧ (x[j] > segéd)
8: x[j + d] ← x[j]
9: j ← j − d
10: ciklus vége
11: x[j + d] ← segéd
12: ciklus vége
13: d ← KövetkezőTávolság(d)
14: ciklus vége
15: eljárás vége

3.9. Algoritmus Szétosztó rendezés
Bemenet: x − T tömb, n − egész (tömb mérete); ahol T kulccsal rendelkezik
Kimenet: y − T rendezett tömb
1: függvény SzétosztóRendezés(x : T tömb, n : egész)
2: y ← Létrehoz(T)[n]
3: ciklus i ← 1-től n-ig
4: y [x[i].kulcs] ← x[i]
5: ciklus vége
6: vissza y
7: függvény vége

3.10. Algoritmus Számlálva szétosztó rendezés
Bemenet: x − T tömb, n − egész (tömb mérete), m − egész; ahol T kulccsal rendelkezik
Kimenet: y − T rendezett tömb
1: függvény SzámlálvaSzétosztóRendezés(x : T tömb, n : egész, m : egész)
2: db ← Létrehoz(egész)[m]
3: ciklus i ← 1-től m-ig
4: db[i] ← 0
5: ciklus vége
6: ciklus i ← 1-től n-ig
7: db [x[i].kulcs] ← db [x[i].kulcs] + 1
8: ciklus vége
9: ciklus i ← 2-től m-ig
10: db[i] ← db[i] + db[i − 1]
11: ciklus vége
12: y ← Létrehoz(T)[n]
13: ciklus i ← 1-től n-ig
14: y [db [x[i].kulcs]] ← x[i]
15: db [x[i].kulcs] ← db [x[i].kulcs] − 1
16: ciklus vége
17: vissza y
18: függvény vége

3.11. Algoritmus Számláló rendezés
Bemenet: x − T tömb, n − egész (tömb mérete); ahol T összehasonlítható
Kimenet: y − T rendezett tömb
1: függvény SzámlálóRendezés(x : T tömb, n : egész)
2: db ← Létrehoz(egész)[n]
3: ciklus i ← 1-től n-ig
4: db[i] ← 1
5: ciklus vége
6: ciklus i ← 1-től n − 1-ig
7: ciklus j ← i + 1-től n-ig
8: ha x[i] > x[j] akkor
9: db[i] ← db[i] + 1
10: különben
11: db[j] ← db[j] + 1
12: elágazás vége
13: ciklus vége
14: ciklus vége
15: y ← Létrehoz(T)[n]
16: ciklus i ← 1-től n-ig
17: y [db[i]] ← x[i]
18: ciklus vége
19: vissza y
20: függvény vége

4.1. Algoritmus Faktoriális iteratív kiszámítása
Bemenet: N − egész (természetes szám)
Kimenet: érték − egész
1: függvény FaktoriálisIteratív(N : egész)
2: érték ← 1
3: ciklus i ← 2-től N -ig
4: érték ← érték · i
5: ciklus vége
6: vissza érték
7: függvény vége

4.2. Algoritmus Faktoriális rekurzív kiszámítása
Bemenet: N − egész (természetes szám)
Kimenet: N faktoriálisa
1: függvény FaktoriálisRekurzív(N : egész)
2: ha N = 0 akkor
3: vissza 1
4: különben
5: vissza N · FaktoriálisRekurzív(N − 1)
6: elágazás vége
7: függvény vége

4.3. Algoritmus Fibonacci sorozat N -edik elemének rekurzív meghatározása
Bemenet: N − egész
Kimenet: N -edik Fibonacci szám
1: függvény FibonacciRekurzív(N : egész)
2: ha N ≤ 1 akkor
3: vissza 1
4: különben
5: vissza FibonacciRekurzív(N − 2) + FibonacciRekurzív(N − 1)
6: elágazás vége
7: függvény vége

4.4. Algoritmus Fibonacci sorozat N -edik elemének iteratív meghatározása
Bemenet: N − egész
Kimenet: aktuális − egész
1: függvény FibonacciIteratív(N : egész)
2: aktuális ← 1
3: előző ← 1
4: ciklus i ← 1-től (N − 1)-ig
5: átmeneti ← aktuális + előző
6: előző ← aktuális
7: aktuális ← átmeneti
8: ciklus vége
9: vissza aktuális
10: függvény vége

4.5. Algoritmus Az első N darab Fibonacci szám megadása
Bemenet: N − egész
Kimenet: x − egész tömb
1: függvény FibonacciKigyűjt(N : egész)
2: x ← Létrehoz(egész)[N ]
3: x[1] ← 1
4: x[2] ← 2
5: ciklus i ← 3-től N -ig
6: x[i] ← x[i − 2] + x[i − 1]
7: ciklus vége
8: vissza x
9: függvény vége

4.6. Algoritmus aN iteratív meghatározása
Bemenet: a − szám, N − egész
Kimenet: érték − szám
1: függvény HatványIteratív(a : szám, N : egész)
2: érték ← a
3: ciklus i ← 2-től N -ig
4: érték ← érték · a
5: ciklus vége
6: vissza érték
7: függvény vége

4.7. Algoritmus aN rekurzív meghatározása
Bemenet: a − szám, N − egész
Kimenet: aN értéke
1: függvény HatványRekurzív(a : szám, N : egész)
2: ha N = 1 akkor
3: vissza a
4: különben
5: vissza a · HatványRekurzív(a, N − 1)
6: elágazás vége
7: függvény vége

4.8. Algoritmus aN felezéses elvű rekurzív meghatározása
Bemenet: a − szám, N − egész
Kimenet: aN értéke
1: függvény HatványFelező(a : szám, N : egész)
2: ha N = 1 akkor
3: vissza a
4: különben
5: ha N páros akkor
6: segéd ← HatványFelező (a, N
2
)
7: vissza segéd · segéd
8: különben
9: segéd ← HatványFelező (a, N −1
2
)
10: vissza a · segéd · segéd
11: elágazás vége
12: elágazás vége
13: függvény vége

4.9. Algoritmus Hanoi tornyai
Bemenet: N − egész, forrás − rúd, cél − rúd, segéd − rúd
1: eljárás Hanoi(N : egész, forrás : rúd, cél : rúd, segéd : rúd)
2: ha N = 1 akkor
3: Mozgat(1, forrás, cél)
4: különben
5: Hanoi(N − 1, forrás, segéd, cél)
6: Mozgat(N, forrás, cél)
7: Hanoi(N − 1, segéd, cél, forrás)
8: elágazás vége
9: eljárás vége

4.10. Algoritmus Sorozatszámítás programozási tétel rekurzív megvalósítása
Bemenet: x − T tömb, jobb − egész
Kimenet: A vizsgált résztömb elemeire nézve a ⊕ művelet eredménye.
1: függvény SorozatszámításRekurzív(x : T tömb, jobb : egész)
2: ha jobb = 0 akkor
3: vissza érték0
4: különben
5: vissza SorozatszámításRekurzív(x, jobb − 1) ⊕ x[jobb]
6: elágazás vége
7: függvény vége

4.11. Algoritmus Lineáris keresés programozási tétel rekurzív megvalósítása
Bemenet: x − T tömb, bal − egész, n − egész (tömb mérete), P − logikai (tulajdonság)
Kimenet: Az első P tulajdonságú elem indexe, illetve ha nincs P tulajdonságú elem, akkor 0.
1: függvény LineárisKeresésRekurzív(x : T tömb, bal : egész, n : egész, P : logikai)
2: ha bal > n akkor
3: vissza 0
4: különben
5: ha P (x[bal]) akkor
6: vissza bal
7: különben
8: vissza LineárisKeresésRekurzív(x, bal + 1, n, P )
9: elágazás vége
10: elágazás vége
11: függvény vége

4.12. Algoritmus Megszámlálás programozási tétel rekurzív megvalósítása
Bemenet: x − T tömb, jobb − egész, P − logikai (tulajdonság)
Kimenet: A vizsgált résztömbben az P tulajdonságú elemek száma.
1: függvény MegszámlálásRekurzív(x : T tömb, jobb : egész, P : logikai)
2: ha jobb = 0 akkor
3: vissza 0
4: különben
5: ha P (x[jobb]) akkor
6: vissza 1 + MegszámlálásRekurzív(x, jobb − 1, P )
7: különben
8: vissza MegszámlálásRekurzív(x, jobb − 1, P )
9: elágazás vége
10: elágazás vége
11: függvény vége

4.13. Algoritmus Maximumkiválasztás programozási tétel rekurzív megvalósítása
Bemenet: x − T tömb, jobb − egész; ahol T összehasonlítható
Kimenet: A vizsgált résztömbben a maximális értékű elem indexe.
1: függvény MaximumkiválasztásRekurzív(x : T tömb, jobb : egész)
2: ha jobb = 1 akkor
3: vissza 1
4: különben
5: max ← MaximumkiválasztásRekurzív(x, jobb − 1)
6: ha x[jobb] > x[max] akkor
7: vissza jobb
8: különben
9: vissza max
10: elágazás vége
11: elágazás vége
12: függvény vége

5.1. Algoritmus Lineáris keresés rendezett tömbben
Bemenet: x − T rendezett tömb, n − egész (tömb mérete), érték − T; ahol T összehasonlítható
Kimenet: van − logikai, idx − egész
1: függvény LineárisKeresésRendezettben(x : T rendezett tömb, n : egész, érték : T)
2: i ← 1
3: ciklus amíg (i ≤ n) ∧ (x[i] < érték)
4: i ← i + 1
5: ciklus vége
6: van ← (i ≤ n) ∧ (x[i] = érték)
7: ha van akkor
8: idx ← i
9: vissza (van, idx)
10: különben
11: vissza van
12: elágazás vége
13: függvény vége

5.2. Algoritmus Logaritmikus keresés iteratív megvalósítása
Bemenet: x − T rendezett tömb, n − egész, érték − T; ahol T összehasonlítható
Kimenet: van − logikai, idx − egész
1: függvény LogaritmikusKeresés(x : T rendezett tömb, n : egész, érték : T)
2: bal ← 1
3: jobb ← n
4: center ←
⌊ bal+jobb
2
⌋
5: ciklus amíg (bal ≤ jobb) ∧ (x[center] 6 = érték)
6: ha x[center] > érték akkor
7: jobb ← center − 1
8: különben
9: bal ← center + 1
10: elágazás vége
11: center ←
⌊ bal+jobb
2
⌋
12: ciklus vége
13: van ← (bal ≤ jobb)
14: ha van akkor
15: idx ← center
16: vissza (van, idx)
17: különben
18: vissza van
19: elágazás vége
20: függvény vége

5.3. Algoritmus Logaritmikus keresés rekurzív megvalósítása
Bemenet: x − T rendezett tömb, bal − egész, jobb − egész, érték − T; ahol T összehasonlítható
Kimenet: Az érték-kel megegyező elem indexe, illetve ha nincs ilyen, akkor 0.
1: függvény LogaritmikusKeresésRekurzív(x : T rendezett tömb, bal : egész, jobb :
egész, érték : T)
2: ha bal > jobb akkor
3: vissza 0
4: különben
5: center ←
⌊ bal+jobb
2
⌋
6: ha x[center] = érték akkor
7: vissza center
8: különben
9: ha x[center] > érték akkor
10: vissza LogaritmikusKeresésRekurzív(x, bal, center − 1, érték)
11: különben
12: vissza LogaritmikusKeresésRekurzív(x, center + 1, jobb, érték)
13: elágazás vége
14: elágazás vége
15: elágazás vége
16: függvény vége

5.4. Algoritmus Eldöntés programozási tétel rendezett tömbben
Bemenet: x − T rendezett tömb, n − egész (tömb mérete), érték − T; ahol T összehasonlítható
Kimenet: van − logikai
1: függvény EldöntésRendezettben(x : T rendezett tömb, n : egész, érték : T)
2: bal ← 1
3: jobb ← n
4: center ←
⌊ bal+jobb
2
⌋
5: ciklus amíg (bal ≤ jobb) ∧ (x[center] 6 = érték)
6: ha x[center] > érték akkor
7: jobb ← center − 1
8: különben
9: bal ← center + 1
10: elágazás vége
11: center ←
⌊ bal+jobb
2
⌋
12: ciklus vége
13: van ← (bal ≤ jobb)
14: vissza van
15: függvény vége

5.5. Algoritmus Módosított eldöntés programozási tétel rendezett tömbben
Bemenet: x − T rendezett tömb, n − egész (tömb mérete), alsóhatár − T, f elsőhatár −
T; ahol T összehasonlítható
Kimenet: van − logikai
1: függvény MódosítottEldöntésRendezettben(x : T rendezett tömb, n : egész, alsóhatár :
T, felsőhatár : T)
2: bal ← 1
3: jobb ← n
4: center ←
⌊ bal+jobb
2
⌋
5: ciklus amíg (bal ≤ jobb) ∧ ¬ ((alsóhatár ≤ x[center]) ∧ (x[center] ≤ f elsőhatár))
6: ha x[center] > f elsőhatár akkor
7: jobb ← center − 1
8: különben
9: bal ← center + 1
10: elágazás vége
11: center ←
⌊ bal+jobb
2
⌋
12: ciklus vége
13: van ← (bal ≤ jobb)
14: vissza van
15: függvény vége

5.6. Algoritmus Kiválasztás programozási tétel rendezettben
Bemenet: x − T rendezett tömb, n − egész, érték − T; ahol T összehasonlítható
Kimenet: idx − egész
1: függvény KiválasztásRendezettben(x : T rendezett tömb, n : egész, érték : T)
2: bal ← 1
3: jobb ← n
4: center ←
⌊ bal+jobb
2
⌋
5: ciklus amíg x[center] 6 = érték
6: ha x[center] > érték akkor
7: jobb ← center − 1
8: különben
9: bal ← center + 1
10: elágazás vége
11: center ←
⌊ bal+jobb
2
⌋
12: ciklus vége
13: idx ← center
14: vissza idx
15: függvény vége

5.7. Algoritmus Kiválogatás programozási tétel rendezett tömbben
Bemenet: x − T rendezett tömb, n − egész, érték − T; ahol T összehasonlítható
Kimenet: van − logikai, bal − egész, jobb − egész
1: függvény KiválogatásRendezettben(x : T rendezett tömb, n : egész, érték : T)
2: bal ← 1
3: jobb ← n
4: center ←
⌊ bal+jobb
2
⌋
5: ciklus amíg (bal ≤ jobb) ∧ (x[center] 6 = érték)
6: ha x[center] > érték akkor
7: jobb ← center − 1
8: különben
9: bal ← center + 1
10: elágazás vége
11: center ←
⌊ bal+jobb
2
⌋
12: ciklus vége
13: van ← (bal ≤ jobb)
14: ha van akkor
15: bal ← center
16: ciklus amíg (bal > 1) ∧ (x[bal − 1] = érték)
17: bal ← bal − 1
18: ciklus vége
19: jobb ← center
20: ciklus amíg (jobb < n) ∧ (x[jobb + 1] = érték)
21: jobb ← jobb + 1
22: ciklus vége
23: vissza (van, bal, jobb)
24: különben
25: vissza van
26: elágazás vége
27: függvény vége

.8. Algoritmus Módosított kiválogatás programozási tétel rendezett tömbben
Bemenet: x−T rendezett tömb, n−egész, alsóhatár−T, f elsőhatár−T; ahol T összehasonlítható
Kimenet: van − logikai, bal − egész, jobb − egész
1: függvény MódosítottKiválogatásRendezettben(x : T rendezett tömb, n : egész, alsóhatár
: T, felsőhatár : T)
2: bal ← 1
3: jobb ← n
4: center ←
⌊ bal+jobb
2
⌋
5: ciklus amíg (bal ≤ jobb) ∧ ¬ ((alsóhatár ≤ x[center]) ∧ (x[center] ≤ f elsőhatár))
6: ha x[center] > f elsőhatár akkor
7: jobb ← center − 1
8: különben
9: bal ← center + 1
10: elágazás vége
11: center ←
⌊ bal+jobb
2
⌋
12: ciklus vége
13: van ← (bal ≤ jobb)
14: ha van akkor
15: bal ← center
16: ciklus amíg (bal > 1) ∧ (x[bal − 1] ≥ alsóhatár)
17: bal ← bal − 1
18: ciklus vége
19: jobb ← center
20: ciklus amíg (jobb < n) ∧ (x[jobb + 1] ≤ f elsőhatár)
21: jobb ← jobb + 1
22: ciklus vége
23: vissza (van, bal, jobb)
24: különben
25: vissza van
26: elágazás vége
27: függvény vége

5.9. Algoritmus Megszámlálás programozási tétel rendezett tömbben
Bemenet: x − T rendezett tömb, n − egész, érték − T; ahol T összehasonlítható
Kimenet: db − egész
1: függvény MegszámlálásRendezettben(x : T rendezett tömb, n : egész, érték : T)
2: bal ← 1
3: jobb ← n
4: center ←
⌊ bal+jobb
2
⌋
5: ciklus amíg (bal ≤ jobb) ∧ (x[center] 6 = érték)
6: ha x[center] > érték akkor
7: jobb ← center − 1
8: különben
9: bal ← center + 1
10: elágazás vége
11: center ←
⌊ bal+jobb
2
⌋
12: ciklus vége
13: ha bal ≤ jobb akkor
14: bal ← center
15: ciklus amíg (bal > 1) ∧ (x[bal − 1] = érték)
16: bal ← bal − 1
17: ciklus vége
18: jobb ← center
19: ciklus amíg (jobb < n) ∧ (x[jobb + 1] = érték)
20: jobb ← jobb + 1
21: ciklus vége
22: db ← jobb − bal + 1
23: különben
24: db ← 0
25: elágazás vége
26: vissza db
27: függvény vége

5.10. Algoritmus Halmaztulajdonság vizsgálata
Bemenet: x − T rendezett tömb, n − egész (tömb mérete); ahol T összehasonlítható
Kimenet: l − logikai
1: függvény HalmazE(x : T rendezett tömb, n : egész)
2: i ← 2
3: ciklus amíg (i ≤ n) ∧ (x[i] 6 = x[i − 1])
4: i ← i + 1
5: ciklus vége
6: l ← (i > n)
7: vissza l
8: függvény vég

5.11. Algoritmus Halmaz létrehozása
Bemenet: x − T rendezett tömb, n − egész (tömb mérete); ahol T összehasonlítható
Kimenet: a − T halmaz, db − egész
1: függvény HalmazLétrehozás(x : T rendezett tömb, n : egész)
2: a ← Létrehoz(T)[n]
3: db ← 1
4: a[db] ← x[1]
5: ciklus i ← 2-től n-ig
6: ha x[i] 6 = a[db] akkor
7: db ← db + 1
8: a[db] ← x[i]
9: elágazás vége
10: ciklus vége
11: vissza (a, db)
12: függvény vége

5.12. Algoritmus Tartalmazás vizsgálat
Bemenet: a − T halmaz, n − egész (halmaz mérete), érték − T; ahol T összehasonlítható
Kimenet: l − logikai
1: függvény TartalmazzaE(a : T halmaz, n : egész, érték : T)
2: bal ← 1
3: jobb ← n
4: center ←
⌊ bal+jobb
2
⌋
5: ciklus amíg (bal ≤ jobb) ∧ (a[center] 6 = érték)
6: ha a[center] > érték akkor
7: jobb ← center − 1
8: különben
9: bal ← center + 1
10: elágazás vége
11: center ←
⌊ bal+jobb
2
⌋
12: ciklus vége
13: l ← (bal ≤ jobb)
14: vissza l
15: függvény vége

5.13. Algoritmus Részhalmaz vizsgálat
Bemenet: a − T halmaz, m − egész (a mérete), b − T halmaz, n − T halmaz (b mérete)
Kimenet: l − logikai
1: függvény Részhalmaz_e(a : T halmaz, m : egész, b : T halmaz, n : egész)
2: i ← 1
3: j ← 1
4: ciklus amíg (i ≤ m) ∧ (j ≤ n) ∧ (a[i] ≥ b[j])
5: ha a[i] = b[j] akkor
6: i ← i + 1
7: elágazás vége
8: j ← j + 1
9: ciklus vége
10: l ← (i > m)
11: vissza l
12: függvény vége

5.14. Algoritmus Halmazok uniója
Bemenet: a1 − T halmaz, n1 − egész (halmaz mérete), a2 − T halmaz, n2 − egész (halmaz mérete)
Kimenet: b − T halmaz, db − egész
1: függvény HalmazUnió(a1 : T halmaz, n1 : egész, a2 : T halmaz, n2 : egész)
2: b ← Létrehoz(T)[n1 + n2]
3: i ← 1
4: j ← 1
5: db ← 0
6: n1 ← n1 + 1
7: a1[n1] ← +∞
8: n2 ← n2 + 1
9: a2[n2] ← +∞
10: ciklus amíg (i < n1) ∨ (j < n2)
11: db ← db + 1
12: ha a1[i] < a2[j] akkor
13: b[db] ← a1[i]
14: i ← i + 1
15: különben
16: ha a1[i] > a2[j] akkor
17: b[db] ← a2[j]
18: j ← j + 1
19: különben
20: b[db] ← a1[i]
21: i ← i + 1
22: j ← j + 1
23: elágazás vége
24: elágazás vége
25: ciklus vége
26: vissza (b, db)
27: függvény vége

5.15. Algoritmus Halmazok metszete
Bemenet: a1 − T halmaz, n1 − egész (halmaz mérete), a2 − T halmaz, n2 − egész (halmaz mérete)
Kimenet: b − T halmaz, db − egész
1: függvény HalmazMetszet(a1 : T halmaz, n1 : egész, a2 : T halmaz, n2 : egész)
2: b ← Létrehoz(T)[min(n1, n2)]
3: i ← 1
4: j ← 1
5: db ← 0
6: ciklus amíg (i ≤ n1) ∧ (j ≤ n2)
7: ha a1[i] < a2[j] akkor
8: i ← i + 1
9: különben ha a1[i] > a2[j] akkor
10: j ← j + 1
11: különben
12: db ← db + 1
13: b[db] ← a1[i]
14: i ← i + 1
15: j ← j + 1
16: elágazás vége
17: ciklus vége
18: vissza (b, db)
19: függvény vége

5.16. Algoritmus Halmazok különbsége
Bemenet: a1 − T halmaz, n1 − egész (halmaz mérete), a2 − T halmaz, n2 − egész (halmaz mérete)
Kimenet: b − T halmaz, db − egész
1: függvény HalmazKulonbseg(a1 : T halmaz, n1 : egész, a2 : T halmaz, n2 : egész)
2: b ← Létrehoz(T)[n1]
3: i ← 1
4: j ← 1
5: db ← 0
6: ciklus amíg (i ≤ n1) ∧ (j ≤ n2)
7: ha a1[i] < a2[j] akkor
8: db ← db + 1
9: b[db] ← a1[i]
10: i ← i + 1
11: különben ha a1[i] > a2[j] akkor
12: j ← j + 1
13: különben
14: i ← i + 1
15: j ← j + 1
16: elágazás vége
17: ciklus vége
18: ciklus amíg i ≤ n1
19: db ← db + 1
20: b[db] ← a1[i]
21: i ← i + 1
22: ciklus vége
23: vissza (b, db)
24: függvény vége

5.17. Algoritmus Halmazok szimmetrikus differenciája
Bemenet: a1 − T halmaz, n1 − egész (halmaz mérete), a2 − T halmaz, n2 − egész (halmaz mérete)
Kimenet: b − T halmaz, db − egész
1: függvény HalmazSzimmetrikusDifferencia(a1 : T halmaz, n1 : egész, a2 : T halmaz, n2 :
egész)
2: b ← Létrehoz(T)[n1 + n2]
3: i ← 1
4: j ← 1
5: db ← 0
6: ciklus amíg (i ≤ n1) ∧ (j ≤ n2)
7: ha a1[i] < a2[j] akkor
8: db ← db + 1
9: b[db] ← a1[i]
10: i ← i + 1
11: különben ha a1[i] > a2[j] akkor
12: db ← db + 1
13: b[db] ← a2[j]
14: j ← j + 1
15: különben
16: i ← i + 1
17: j ← j + 1
18: elágazás vége
19: ciklus vége
20: ciklus amíg i ≤ n1
21: db ← db + 1
22: b[db] ← a1[i]
23: i ← i + 1
24: ciklus vége
25: ciklus amíg j ≤ n2
26: db ← db + 1
27: b[db] ← a2[j]
28: j ← j + 1
29: ciklus vége
30: vissza (b, db)
31: függvény vége

6.1. Algoritmus Felező maximumkiválasztás
Bemenet: x − T tömb, bal − egész, jobb − egész; ahol T összehasonlítható
Kimenet: Az x tömb bal és jobb indexei közötti résztömbje maximális elemének indexe.
1: függvény FelezőMaximumkiválasztás(x : T tömb, bal : egész, jobb : egész)
2: ha bal = jobb akkor
3: vissza bal
4: különben
5: center ←
⌊ bal+jobb
2
⌋
6: balmax ← FelezőMaximumkiválasztás(x, bal, center)
7: jobbmax ← FelezőMaximumkiválasztás(x, center + 1, jobb)
8: ha x[balmax] ≥ x[jobbmax] akkor
9: vissza balmax
10: különben
11: vissza jobbmax
12: elágazás vége
13: elágazás vége
14: függvény vége

6.2. Algoritmus Összefésülő rendezés
Bemenet: x − T tömb, bal − egész, jobb − egész; ahol T összehasonlítható
Kimenet: x − T rendezett tömb
1: eljárás ÖsszefésülőRendezés(címszerint x : T tömb, bal : egész, jobb : egész)
2: ha bal < jobb akkor
3: center ←
[ bal+jobb
2
]
4: ÖsszefésülőRendezés(x, bal, center)
5: ÖsszefésülőRendezés(x, center + 1, jobb)
6: Összefésül(x, bal, center, jobb)
7: elágazás vége
8: eljárás vége

6.3. Algoritmus Összefésülés
Bemenet: x − T tömb, bal − egész, center − egész, jobb − egész; ahol T összehasonlítható
Kimenet: x − T tömb
1: eljárás Összefésül(címszerint x : T tömb, bal : egész, center : egész, jobb : egész)
2: n1 ← center − bal + 1
3: n2 ← jobb − center
4: y1 ← Létrehoz(T)[n1 + 1]
5: ciklus i ← 1-től n1-ig
6: y1[i] ← x[bal + i − 1]
7: ciklus vége
8: y2 ← Létrehoz(T)[n2 + 1]
9: ciklus j ← 1-től n2-ig
10: y2[j] ← x[center + j]
11: ciklus vége
12: y1[n1 + 1] ← +∞
13: y2[n2 + 1] ← +∞
14: i ← 1
15: j ← 1
16: ciklus k ← bal-től jobb-ig
17: ha y1[i] ≤ y2[j] akkor
18: x[k] ← y1[i]
19: i ← i + 1
20: különben
21: x[k] ← y2[j]
22: j ← j + 1
23: elágazás vége
24: ciklus vége
25: eljárás vége

6.4. Algoritmus Gyorsrendezés
Bemenet: x − T tömb, bal − egész, jobb − egész; ahol T összehasonlítható
Kimenet: x − T rendezett tömb
1: eljárás GyorsRendezés(címszerint x : T tömb, bal : egész, jobb : egész)
2: idx ← Szétválogat(x, bal, jobb)
3: ha idx > bal + 1 akkor
4: GyorsRendezés(x, bal, idx − 1)
5: elágazás vége
6: ha idx < jobb − 1 akkor
7: GyorsRendezés(x, idx + 1, jobb)
8: elágazás vége
9: eljárás vége

6.5. Algoritmus Gyorsrendezés szétválogatása
Bemenet: x − T tömb, bal − egész, jobb − egész; ahol T összehasonlítható
Kimenet: x − T tömb, idx − egész
1: függvény Szétválogat(címszerint x : T tömb, bal : egész, jobb : egész)
2: segéd ← x[bal]
3: ciklus amíg bal < jobb
4: ciklus amíg (bal < jobb) ∧ (x[jobb] > segéd)
5: jobb ← jobb − 1
6: ciklus vége
7: ha bal < jobb akkor
8: x[bal] ← x[jobb]
9: bal ← bal + 1
10: ciklus amíg (bal < jobb) ∧ (x[bal] ≤ segéd)
11: bal ← bal + 1
12: ciklus vége
13: ha bal < jobb akkor
14: x[jobb] ← x[bal]
15: jobb ← jobb − 1
16: elágazás vége
17: elágazás vége
18: ciklus vége
19: idx ← bal
20: x[idx] ← segéd
21: vissza idx
22: függvény vége

6.6. Algoritmus k-adik legkisebb elem kiválasztása
Bemenet: x − T tömb, bal − egész, jobb − egész, k − egész; ahol T összehasonlítható
Kimenet: k-adik legkisebb tömbelem értéke
1: függvény k-adikLegkisebbElem(x : T tömb, bal : egész, jobb : egész, k : egész)
2: ha bal = jobb akkor
3: vissza x[bal]
4: különben
5: idx ← Szétválogat(x, bal, jobb)
6: ha k = idx − bal + 1 akkor
7: vissza x[idx]
8: különben ha k < idx − bal + 1 akkor
9: vissza k-adikLegkisebbElem(x, bal, idx − 1, k)
10: különben
11: vissza k-adikLegkisebbElem(x, idx + 1, jobb, k − (idx − bal + 1))
12: elágazás vége
13: elágazás vége
14: függvény vége

7.1. Algoritmus 0-1 hátizsák probléma
Bemenet: p − egész tömb, w − egész tömb, n − egész (tömb mérete), c − egész
Kimenet: F − egész tábla
1: függvény 0-1Hátizsák(p : egész tömb, w : egész tömb, n : egész, c : egész)
2: F ← TáblaLétrehoz(egész)[n + 1, c + 1]
3: ciklus x ← 0-től c-ig
4: F [0, x] ← 0
5: ciklus vége
6: ciklus i ← 1-től n-ig
7: F [i, 0] ← 0
8: ciklus vége
9: ciklus i ← 1-től n-ig
10: ciklus x ← 1-től c-ig
11: ha wi ≤ x akkor
12: F [i, x] ← max (F [i − 1, x], F [i − 1, x − wi] + pi)
13: különben
14: F [i, x] ← F [i − 1, x]
15: elágazás vége
16: ciklus vége
17: ciklus vége
18: vissza F
19: függvény vége

7.2. Algoritmus Kiválasztott elemek kiolvasása
Bemenet: F − egész tábla, n − egész, c − egész
Kimenet: S − egész halmaz
1: függvény Kiolvas(F : egész tábla, n : egész, c : egész)
2: S ← ∅
3: i ← n
4: x ← c
5: ciklus amíg (i > 0) ∧ (x > 0)
6: ha F [i, x] 6 = F [i − 1, x] akkor
7: S ← S ∪ {i}
8: x ← x − wi
9: elágazás vége
10: i ← i − 1
11: ciklus vége
12: vissza S
13: függvény vége

7.3. Algoritmus Leghosszabb közös részsorozat hossza
Bemenet: X − T tömb, n − egész (tömb mérete), Y − T tömb, m − egész (tömb mérete)
Kimenet: F − egész tábla
1: függvény LKRHossza(X : T tömb, n : egész, Y : T tömb, m : egész)
2: F ← TáblaLétrehoz(egész)[n + 1, m + 1]
3: ciklus j ← 0-től m-ig
4: F [0, j] ← 0
5: ciklus vége
6: ciklus i ← 1-től n-ig
7: F [i, 0] ← 0
8: ciklus vége
9: ciklus i ← 1-től n-ig
10: ciklus j ← 1-től m-ig
11: ha xi = yj akkor
12: F [i, j] ← F [i − 1, j − 1] + 1
13: különben
14: F [i, j] ← max {F [i − 1, j], F [i, j − 1]}
15: elágazás vége
16: ciklus vége
17: ciklus vége
18: vissza F
19: függvény vége

7.4. Algoritmus Leghosszabb közös részsorozat előállítása
Bemenet: F − egész tábla, X − T tömb, n − egész, Y − T tömb, m − egész
Kimenet: S − T tömb
1: függvény LKRElőállítás(F : egész tábla, X : T tömb, n : egész, Y : T tömb, m : egész)
2: S ← Létrehoz(T)[F [n, m]]
3: i ← n
4: j ← m
5: idx ← F [n, m]
6: ciklus amíg idx > 0
7: ha X[i] = Y [j] akkor
8: S[idx] ← X[i]
9: idx ← idx − 1
10: i ← i − 1
11: j ← j − 1
12: különben ha F [i − 1, j] > F [i, j − 1] akkor
13: i ← i − 1
14: különben
15: j ← j − 1
16: elágazás vége
17: ciklus vége
18: vissza S
19: függvény vége

7.5. Algoritmus Pénzkifizetés mohó algoritmusa
Bemenet: x − egész, c − egész rendezett tömb, n − egész
Kimenet: db − egész tömb
1: függvény Pénzkifizetés(x : egész, c : egész tömb, n : egész)
2: db ← Létrehoz(egész)[n]
3: ciklus i ← 1-től n-ig
4: db[i] ← 0
5: ciklus vége
6: j ← n
7: ciklus amíg x > 0
8: ciklus amíg c[j] > x
9: j ← j − 1
10: ciklus vége
11: db[j] ← db[j] + 1
12: x ← x − c[j]
13: ciklus vége
14: vissza db
15: függvény vége

7.6. Algoritmus 0-1 hátizsák probléma mohó megoldása
Bemenet: p − egész tömb, w − egész tömb, n − egész (tömb mérete), c − egész
Kimenet: S − egész halmaz
1: függvény Mohó0-1Hátizsák(p : egész tömb, w : egész tömb, n : egész, c : egész)
2: S ← ∅
3: i ← 1
4: ciklus amíg (c > 0) ∧ (i ≤ n)
5: ha w[i] ≤ c akkor
6: S ← S ∪ {i}
7: c ← c − w[i]
8: elágazás vége
9: i ← i + 1
10: ciklus vége
11: vissza S
12: függvény vége

7.7. Algoritmus Összegyűjtött kincsek összege (dinamikus programozás)
Bemenet: C − egész tömb, m − egész (C sorainak száma), n − egész (C oszlopainak száma)
Kimenet: F − egész tömb
1: függvény KincsÖsszeg(C : egész tömb, m : egész, n : egész)
2: F ← Létrehoz(egész)[m, n]
3: F [1, 1] = C[1, 1]
4: ciklus j ← 2-től n-ig
5: F [1, j] = F [1, j − 1] + C[i, j]
6: ciklus vége
7: ciklus i ← 2-től m-ig
8: F [i, 1] = F [i − 1, 1] + C[i, j]
9: ciklus vége
10: ciklus i ← 2-től m-ig
11: ciklus j ← 2-től n-ig
12: F [i, j] = max (F [i − 1, j], F [i, j − 1]) + C[i, j]
13: ciklus vége
14: ciklus vége
15: vissza F
16: függvény vége

7.8. Algoritmus Bejárási út kiolvasása (dinamikus programozás)
Bemenet: F − egész tömb, m − egész (F sorainak száma), n − egész (F oszlopainak száma)
Kimenet: P − egész tömb
1: függvény BejárásiÚtKiolvas(F : egész tömb, m : egész, n : egész)
2: P ← Létrehoz(egész)[m + n − 1]
3: i ← m
4: j ← n
5: k ← m + n − 1
6: ciklus amíg (i ≥ 2) ∧ (j ≥ 2)
7: P [k] ← (i, j)
8: k ← k − 1
9: ha F [i − 1, j] > F [i, j − 1] akkor
10: i ← i − 1
11: különben
12: j ← j − 1
13: elágazás vége
14: ciklus vége
15: ciklus amíg i ≥ 2
16: P [k] ← (i, j)
17: k ← k − 1
18: i ← i − 1
19: ciklus vége
20: ciklus amíg j ≥ 2
21: P [k] ← (i, j)
22: k ← k − 1
23: j ← j − 1
24: ciklus vége
25: P [1] ← (1, 1)
26: vissza P
27: függvény vége

7.9. Algoritmus Kincsek begyűjtése (mohó algoritmus)
Bemenet: C − egész tömb, m − egész (C sorainak száma), n − egész (C oszlopainak száma)
Kimenet: P − egész tömb
1: függvény MohóKincsGyűjtés(C : egész tömb, m : egész, n : egész)
2: P ← Létrehoz(egész)[m + n − 1]
3: i ← 1
4: j ← 1
5: k ← 0
6: ciklus amíg (i < m) ∧ (j < n)
7: k ← k + 1
8: P [k] ← (i, j)
9: ha C[i + 1, j] > C[i, j + 1] akkor
10: i ← i + 1
11: különben
12: j ← j + 1
13: elágazás vége
14: ciklus vége
15: ciklus amíg i < m
16: k ← k + 1
17: P [k] ← (i, j)
18: i ← i + 1
19: ciklus vége
20: ciklus amíg j < n
21: k ← k + 1
22: P [k] ← (i, j)
23: j ← j + 1
24: ciklus vége
25: k ← k + 1
26: P [k] ← (i, j)
27: vissza P
28: függvény vége

7.10. Algoritmus Esemény kiválasztás
Bemenet: s − idő tömb, f − idő rendezett tömb, n − egész (tömbök mérete)
Kimenet: A − egész halmaz
1: függvény EseményKiválasztás(s : idő tömb, f : idő tömb, negész)
2: A ← {1}
3: utolsó ← 1
4: ciklus i ← 2-től n-ig
5: ha s[i] ≥ f [utolsó] akkor
6: A ← A ∪ {i}
7: utolsó ← i
8: elágazás vége
9: ciklus vége
10: vissza A
11: függvény vég

7.11. Algoritmus Esemény elkülönítés
Bemenet: s − idő rendezett tömb, f − idő tömb, n − egész (tömbök mérete)
Kimenet: A − egész tömb
1: függvény EseményElkülönítés(s : idő rendezett tömb, f : idő tömb, n : egész)
2: A ← Létrehoz(egész)[n]
3: utolsó ← 0
4: ciklus i ← 1-től n-ig
5: j ← 1
6: ciklus amíg (j ≤ utolsó) ∧ ¬KompatiblisEseményErőforrással(A, s, f, i, j)
7: j ← j + 1
8: ciklus vége
9: ha j ≤ utolsó akkor
10: A[i] ← j
11: különben
12: utolsó ← utolsó + 1
13: A[i] ← utolsó
14: elágazás vége
15: ciklus vége
16: vissza A
17: függvény vége

7.12. Algoritmus Ütemezés késés minimalizálással
Bemenet: d − idő rendezett tömb, t − idő tömb, n − egész (tömbök mérete)
Kimenet: s − idő tömb, f − idő tömb
1: függvény KésésMinimalizálás(d : idő rendezett tömb, t : idő tömb, n : egész)
2: s ← Létrehoz(idő)[n]
3: f ← Létrehoz(idő)[n]
4: utolsó ← 0
5: ciklus i ← 1-től n-ig
6: s[i] ← utolsó
7: f [i] ← s[i] + t[i]
8: utolsó ← f [i]
9: ciklus vége
10: vissza (s, f )
11: függvény vége

8.1. Algoritmus Kupactulajdonság fenntartása
Bemenet: x − T tömb, n − egész (tömb mérete), k − egész (kupac mérete), i −
egész; ahol T összehasonlítható
Kimenet: x − T tömb
1: eljárás Kupacol(címszerint x : T tömb, n : egész, k : egész, i : egész)
2: bal ← 2 · i
3: jobb ← 2 · i + 1
4: ha bal ≤ k ∧ x[bal] > x[i] akkor
5: max ← bal
6: különben
7: max ← i
8: elágazás vége
9: ha jobb ≤ k ∧ x[jobb] > x[max] akkor
10: max ← jobb
11: elágazás vége
12: ha max 6 = i akkor
13: x[i] ↔ x[max]
14: Kupacol(x, n, k, max)
15: elágazás vége
16: eljárás vége

8.2. Algoritmus Kupac építése
Bemenet: x − T tömb, n − egész (tömb mérete); ahol T összehasonlítható
Kimenet: x − T kupac
1: eljárás KupacotÉpít(címszerint x : T tömb, n : egész)
2: ciklus i ← bn/2c-től 1-ig
3: Kupacol(x, n, n, i)
4: ciklus vége
5: eljárás vége

8.3. Algoritmus Kupacrendezés
Bemenet: x − T tömb, n − egész (tömb mérete); ahol T összehasonlítható
Kimenet: x − T rendezett tömb
1: eljárás Kupacrendezes(címszerint x : T tömb, n : egész)
2: KupacotÉpít(x, n)
3: ciklus i ← n-től 2-ig
4: x[1] ↔ x[i]
5: Kupacol(x, n, i − 1, 1)
6: ciklus vége
7: eljárás vége
