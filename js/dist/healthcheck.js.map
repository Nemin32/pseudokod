{
  "version": 3,
  "sources": ["../src/interfaces/ITokenizer.ts", "../src/parser/tokenizer.ts", "../src/frontend/token.ts", "../src/interfaces/types.ts", "../src/interfaces/astkinds.ts", "../src/compiler/typecheck.ts", "../src/parser/monadic_parser_base.ts", "../src/parser/ast_parser.ts", "../src/compiler/typemap.ts", "../src/frontend/healthcheck.ts"],
  "sourcesContent": ["// string -> IToken[]\nexport enum TokenType {\n  /* Keywords */\n  AKKOR = 0,\n  AMIG = 1,\n  CIKLUS = 2,\n  CIMSZERINT = 3,\n  DEBUG = 4,\n  ELAGAZAS = 5,\n  FUGGVENY = 6,\n  HA = 7,\n  KIIR = 8,\n  KULONBEN = 9,\n  LETREHOZ = 10,\n  TABLALETREHOZ = 11,\n  TOMB = 12,\n  VEGE = 13,\n  VISSZA = 14,\n\n  /* Misc. */\n  NEGAL = 15,\n  OPAREN = 16,\n  CPAREN = 17,\n  OBRACKET = 18,\n  CBRACKET = 19,\n  COLON = 20,\n  COMMA = 21,\n  FORSTART = 22,\n  FOREND = 23,\n  NYIL = 24,\n  SWAP = 25,\n  REFERENCE = 26,\n\n  /* Special */\n  NUMBER = 27,\n  BOOLEAN = 28,\n  STRING = 29,\n  SYMBOL = 30,\n  FUNCNAME = 31,\n  BINOP = 32,\n  WHITESPACE = 33,\n  TYPE = 34,\n  COMMENT = 35,\n  RENDEZETT = 36,\n\n  ERROR = 37,\n}\n\nexport interface Location {\n    readonly row: number,\n    readonly column: number\n}\n\nexport interface IToken {\n  readonly lexeme: string;\n  readonly position: Location\n  readonly length: number;\n  readonly type: TokenType;\n}\n\nexport interface ITokenizer {\n  tokenize(input: string): Array<IToken>;\n}\n", "import { IToken, ITokenizer, TokenType as TT } from \"../interfaces/ITokenizer.ts\";\n\ntype ParseResult = IToken | null;\n\nconst kwToType: ReadonlyMap<string, TT> = new Map([\n\t/* Keywords */\n\t[\"akkor\", TT.AKKOR],\n\t[\"am\u00EDg\", TT.AMIG],\n\t[\"ciklus\", TT.CIKLUS],\n\t[\"c\u00EDmszerint\", TT.CIMSZERINT],\n\t[\"debug\", TT.DEBUG],\n\t[\"el\u00E1gaz\u00E1s\", TT.ELAGAZAS],\n\t[\"f\u00FCggv\u00E9ny\", TT.FUGGVENY],\n\t[\"elj\u00E1r\u00E1s\", TT.FUGGVENY],\n\t[\"ha\", TT.HA],\n\t[\"ki\u00EDr\", TT.KIIR],\n\t[\"k\u00FCl\u00F6nben\", TT.KULONBEN],\n\n\t[\"t\u00F6mb\", TT.TOMB],\n\t[\"halmaz\", TT.TOMB],\n\t[\"t\u00E1bla\", TT.TOMB],\n\n\t[\"vissza\", TT.VISSZA],\n\t[\"v\u00E9ge\", TT.VEGE],\n\t[\"L\u00E9trehoz\", TT.LETREHOZ],\n\t[\"T\u00E1blaL\u00E9trehoz\", TT.TABLALETREHOZ],\n\t[\"rendezett\", TT.RENDEZETT],\n\n\t/* Misc. */\n\t[\"~\", TT.NEGAL],\n\t[\"(\", TT.OPAREN],\n\t[\")\", TT.CPAREN],\n\t[\"[\", TT.OBRACKET],\n\t[\"]\", TT.CBRACKET],\n\t[\":\", TT.COLON],\n\t[\",\", TT.COMMA],\n\t[\"&\", TT.REFERENCE],\n\n\t[\"<-\", TT.NYIL],\n\t[\"<->\", TT.SWAP],\n\t[\"-t\u00F3l\", TT.FORSTART],\n\t[\"-t\u0151l\", TT.FORSTART],\n\t[\"-ig\", TT.FOREND],\n\t[\"//\", TT.COMMENT],\n]);\n\nexport class Tokenizer implements ITokenizer {\n\tinput = \"\";\n\tindex = 0;\n\n\trow = 0;\n\tcolumn = 0;\n\n\t// Helpers\n\tpeek(): string | null {\n\t\tif (this.index >= this.input.length) return null;\n\t\treturn this.input[this.index];\n\t}\n\n\teat(): string | null {\n\t\tif (this.index >= this.input.length) return null;\n\t\tthis.column++;\n\n\t\treturn this.input[this.index++];\n\t}\n\n\teatWhile(fn: (c: string) => boolean): string | null {\n\t\tif (this.peek() === null) return null;\n\t\tlet retval = \"\";\n\n\t\twhile (true) {\n\t\t\tconst c = this.eat();\n\t\t\tif (c == null) return retval;\n\n\t\t\tif (fn.call(this, c)) {\n\t\t\t\tretval += c;\n\t\t\t} else {\n\t\t\t\tthis.index--;\n\t\t\t\tthis.column--;\n\t\t\t\treturn retval.length === 0 ? null : retval;\n\t\t\t}\n\t\t}\n\t}\n\n\tgetKeywordTokenType(kw: string | null): TT | null {\n\t\tif (kw == null) return null;\n\t\treturn kwToType.get(kw) ?? null;\n\t}\n\n\tisWhitespace(char: string): boolean {\n\t\treturn [\" \", \"\\t\", \"\\n\"].includes(char);\n\t}\n\n\tisNum(char: string): boolean {\n\t\treturn char >= \"0\" && char <= \"9\";\n\t}\n\n\tisLetter(char: string): boolean {\n\t\treturn char.toLowerCase() !== char.toUpperCase();\n\t}\n\n\tisLetterOrUnderline(char: string): boolean {\n\t\treturn char.toLowerCase() !== char.toUpperCase() || char === \"_\";\n\t}\n\n\ttryParse(fn: () => IToken | null): IToken | null {\n\t\tconst state = this.saveState();\n\n\t\tconst token = fn.call(this);\n\t\tif (token !== null) return token;\n\n\t\tthis.index = state.index;\n\t\tthis.row = state.row;\n\t\tthis.column = state.column;\n\n\t\treturn null;\n\t}\n\n\tsaveState() {\n\t\treturn {\n\t\t\tindex: this.index,\n\t\t\trow: this.row,\n\t\t\tcolumn: this.column,\n\t\t};\n\t}\n\n\tmkToken(type: TT, tokenFn: () => string | null): ParseResult {\n\t\tconst state = this.saveState();\n\t\tconst value = tokenFn.call(this);\n\t\tif (!value) return null;\n\n\n\n\t\treturn {\n\t\t\tlexeme: value,\n\t\t\tposition: { row: state.row, column: state.column },\n\t\t\tlength: this.index - state.index,\n\t\t\ttype: type,\n\t\t};\n\t}\n\n\t// === Parsers === \n\n\tnewLine(): ParseResult {\n\t\treturn this.mkToken(TT.WHITESPACE, () => {\n\t\t\tlet len = 0;\n\n\t\t\twhile (this.peek() === \"\\n\") {\n\t\t\t\tthis.eat();\n\t\t\t\tthis.column = 0;\n\t\t\t\tthis.row++;\n\t\t\t\tlen++;\n\t\t\t}\n\n\t\t\tif (len === 0) return null;\n\n\t\t\treturn \"\\n\".repeat(len);\n\t\t});\n\t}\n\n\twhitespace(): ParseResult {\n\t\treturn this.mkToken(TT.WHITESPACE, () => {\n\t\t\treturn this.eatWhile(c => c === \" \" || c === \"\\t\");\n\t\t});\n\t}\n\n\tsingleLetterKeyword(): ParseResult {\n\t\tconst char = this.eat();\n\t\tconst type = this.getKeywordTokenType(char) ?? null;\n\n\t\treturn (type == null) ? type : this.mkToken(type, () => char);\n\t}\n\n\tkeyword(): ParseResult {\n\n\n\t\tconst slkw = this.tryParse(this.singleLetterKeyword);\n\t\tif (slkw) return slkw;\n\n\n\n\t\tconst kw = this.eatWhile(c => ![\"[\", \"(\", \",\", \")\", \"]\"].includes(c) && !this.isWhitespace(c));\n\t\tconst type = this.getKeywordTokenType(kw);\n\n\t\tif (type === null) return null;\n\n\t\tconst token = this.mkToken(type, () => kw);\n\n\n\t\tif (!token) return null;\n\n\t\treturn token\n\t}\n\n\tcomment(): ParseResult {\n\t\treturn this.mkToken(TT.COMMENT, () => {\n\t\t\tif (this.eat() !== \"/\" || this.eat() !== \"/\") return null;\n\t\t\tconst comment = this.eatWhile((c) => c !== \"\\n\");\n\t\t\treturn `//${comment}`;\n\t\t});\n\t}\n\n\tnumber(): ParseResult {\n\t\treturn this.mkToken(TT.NUMBER, () => {\n\t\t\tlet negative = false;\n\t\t\tif (this.peek() === \"-\") {\n\t\t\t\tnegative = true;\n\t\t\t\tthis.eat()\n\t\t\t}\n\n\t\t\tconst num = this.eatWhile(this.isNum);\n\t\t\tif (!num) return null;\n\n\t\t\treturn (negative? \"-\" : \"\") + num;\n\t\t});\n\t}\n\n\tstring(): ParseResult {\n\t\treturn this.mkToken(TT.STRING, () => {\n\t\t\tif (this.eat() !== '\"') return null;\n\t\t\tconst inner = this.eatWhile((c) => c !== '\"');\n\t\t\tif (this.eat() !== '\"') return null;\n\n\t\t\treturn inner;\n\t\t});\n\t}\n\n\tbool(): ParseResult {\n\t\treturn this.mkToken(TT.BOOLEAN, () => {\n\t\t\tconst word = this.eatWhile(this.isLetter)\n\t\t\tif (!word || ![\"igaz\", \"Igaz\", \"hamis\", \"Hamis\"].includes(word)) return null;\n\n\t\t\treturn word;\n\t\t})\n\t}\n\n\tbinop(): ParseResult {\n\t\tconst validBinops = [\"<\", \">\", \"=\", \"<=\", \">=\", \"=/=\", \"\u00E9s\", \"vagy\", \"+\", \"-\", \"/\", \"*\", \"mod\"];\n\n\t\treturn this.mkToken(TT.BINOP, () => {\n\t\t\tconst str = (this.eat() ?? \"\") + (this.eat() ?? \"\") + (this.eat() ?? \"\") + (this.eat() ?? \"\");\n\n\t\t\tfor (let i = str.length; i > 0; i--) {\n\t\t\t\tconst sub = str.substring(0, i);\n\t\t\t\tif (validBinops.includes(sub)) {\n\t\t\t\t\t// Mivel n\u00E9gy karaktert \"ett\u00FCnk meg\", \u00EDgy annyival vissza kell l\u00F6kni az indexet,\n\t\t\t\t\t// amennyit v\u00E9g\u00FCl m\u00E9gse haszn\u00E1ltunk fel.\n\t\t\t\t\tthis.index -= str.length - i;\n\t\t\t\t\tthis.column -= str.length - i;\n\n\t\t\t\t\treturn sub;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn null;\n\t\t});\n\t}\n\n\tsymbol(): ParseResult {\n\t\treturn this.mkToken(TT.SYMBOL, () => {\n\t\t\treturn this.eatWhile(c => this.isLetter(c) || this.isNum(c))\n\t\t})\n\t}\n\n\tfuncName(): ParseResult {\n\t\treturn this.mkToken(TT.FUNCNAME, () => {\n\t\t\tconst c = this.eat()\n\t\t\tif (!c || !this.isLetter(c) || c.toUpperCase() !== c) return null;\n\n\t\t\tconst rest = this.eatWhile(this.isLetterOrUnderline)\n\n\t\t\tif (rest?.length === 0) return null;\n\n\t\t\treturn c + (rest ?? \"\");\n\t\t})\n\t}\n\n\ttype(): ParseResult {\n\t\treturn this.mkToken(TT.TYPE, () => {\n\t\t\tconst val = this.eatWhile(this.isLetter);\n\t\t\tif (!val) return null;\n\t\t\treturn [\"eg\u00E9sz\", \"sz\u00F6veg\", \"logikai\"].includes(val) || (val.length === 1 && val >= 'A' && val <= 'Z') ? val : null\n\t\t})\n\t}\n\n\t// === Driver ===\n\n\tparse(): ParseResult {\n\t\tconst parsers = [\n\t\t\tthis.newLine,\n\t\t\tthis.whitespace,\n\t\t\tthis.comment,\n\t\t\tthis.number,\n\t\t\tthis.keyword,\n\t\t\tthis.binop,\n\t\t\tthis.bool,\n\t\t\tthis.string,\n\t\t\tthis.type,\n\t\t\tthis.funcName,\n\t\t\tthis.symbol,\n\t\t];\n\n\t\tfor (const parser of parsers) {\n\t\t\tconst value = this.tryParse(parser);\n\t\t\tif (value) {\n\t\t\t\treturn value;\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tparseWhileNotEOF(): IToken[] {\n\t\tconst retval = [];\n\n\t\twhile (true) {\n\t\t\tconst token = this.parse();\n\t\t\tif (token) {\n\t\t\t\tretval.push(token);\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!(this.peek() === null)) {\n\t\t\tconst errTok = this.mkToken(TT.ERROR, () => this.eatWhile(_ => true))\n\t\t\tif (errTok)\n\t\t\t\tretval.push(errTok)\n\t\t}\n\n\t\treturn retval;\n\t}\n\n\ttokenize(input: string): IToken[] {\n\t\tthis.input = input;\n\t\tthis.index = 0;\n\n\t\treturn this.parseWhileNotEOF();\n\t}\n}\n", "import { IToken, TokenType as TT } from \"../interfaces/ITokenizer.ts\"\nimport { Tokenizer } from \"../parser/tokenizer.ts\"\n\nconst tokenTypeToClass = (tt: TT): string => {\n\tswitch (tt) {\n\t\tcase TT.AKKOR:\n\t\tcase TT.AMIG:\n\t\tcase TT.CIKLUS:\n\t\tcase TT.ELAGAZAS:\n\t\tcase TT.FUGGVENY:\n\t\tcase TT.HA:\n\t\tcase TT.KULONBEN:\n\t\tcase TT.LETREHOZ:\n\t\tcase TT.TABLALETREHOZ:\n\t\tcase TT.VEGE:\n\t\t\treturn \"keyword\";\n\n\t\tcase TT.KIIR:\n\t\tcase TT.VISSZA:\n\t\t\treturn \"statement\";\n\n\t\tcase TT.DEBUG:\n\t\t\treturn \"debug\";\n\n\t\tcase TT.CIMSZERINT:\n\t\tcase TT.RENDEZETT:\n\t\tcase TT.TOMB:\n\t\tcase TT.TYPE:\n\t\t\treturn \"type\";\n\n\t\tcase TT.NEGAL:\n\t\tcase TT.OPAREN:\n\t\tcase TT.CPAREN:\n\t\tcase TT.OBRACKET:\n\t\tcase TT.CBRACKET:\n\t\tcase TT.COLON:\n\t\tcase TT.COMMA:\n\t\tcase TT.FORSTART:\n\t\tcase TT.FOREND:\n\t\tcase TT.NYIL:\n\t\tcase TT.SWAP:\n\t\tcase TT.REFERENCE:\n\t\t\treturn \"nyil\";\n\n\t\tcase TT.NUMBER:\n\t\t\treturn \"number\";\n\t\tcase TT.BOOLEAN:\n\t\t\treturn \"bool\";\n\t\tcase TT.STRING:\n\t\t\treturn \"string\";\n\n\t\tcase TT.FUNCNAME:\n\t\t\treturn \"funcname\";\n\n\t\tcase TT.COMMENT:\n\t\t\treturn \"comment\";\n\n\t\tcase TT.ERROR:\n\t\t\treturn \"error\";\n\n\t\tcase TT.SYMBOL:\n\t\tcase TT.BINOP:\n\t\tcase TT.WHITESPACE:\n\t\t\treturn \"normal\";\n\t}\n}\n\nconst tokenToHTML = (tok: IToken) => {\n\tconst c = document.createElement(\"span\")\n\tc.innerText = tok.lexeme;\n\tc.dataset.row = String(tok.position.row);\n\tc.dataset.column = String(tok.position.column);\n\tc.classList.add(tokenTypeToClass(tok.type));\n\n\tif (tok.lexeme.includes(\"\\n\")) c.dataset.isWS = \"true\";\n\n\treturn c\n}\n\nexport const tokenize = (input: string): [HTMLSpanElement[], IToken[]] => {\n\tconst tok = new Tokenizer()\n\tconst tokensRaw = tok.tokenize(input)\n\tconst tokens = tokensRaw.filter(t => t.type !== TT.WHITESPACE)\n\n\tconst spans = tokensRaw.map(tokenToHTML)\n\n\treturn [spans, tokens]\n}\n", "import { IToken } from \"./ITokenizer.ts\";\nimport { FunctionDeclaration } from \"./astkinds.ts\";\n\nexport enum TypeVariants {\n\tSIMPLE = 0,\n\tARRAY = 1,\n\tREFERENCE = 2,\n\tHETEROGENOUS = 3,\n\tFUNCTION = 4,\n\tGENERIC = 5,\n\n\tNONE = 6,\n\tUNKNOWN = 7,\n}\n\nexport enum BaseType {\n\tNUMBER = 0,\n\tSTRING = 1,\n\tLOGIC = 2,\n}\n\nexport class TypeCheckError extends Error {\n\tconstructor(message: string, readonly token: IToken | null) {\n\t\tsuper(message);\n\t}\n}\n\nexport class SimpleType {\n\treadonly kind = TypeVariants.SIMPLE;\n\tconstructor(readonly t: BaseType) { }\n}\n\nexport class ArrayType {\n\treadonly kind = TypeVariants.ARRAY;\n\tconstructor(readonly t: Type) { }\n}\n\nexport class ReferenceType {\n\treadonly kind = TypeVariants.REFERENCE;\n\tconstructor(readonly t: Type) { }\n}\n\nexport class HeterogenousArrayType {\n\treadonly kind = TypeVariants.HETEROGENOUS;\n\tts: Type[]\n\tconstructor(ts: Type[]) { this.ts = ts.sort() }\n}\n\nexport class NoneType {\n\treadonly kind = TypeVariants.NONE;\n}\n\nexport class UnknownType {\n\treadonly kind = TypeVariants.UNKNOWN;\n}\n\nexport class FunctionType {\n\treadonly kind = TypeVariants.FUNCTION;\n\n\tconstructor(readonly rType: Type, readonly argTypes: Type[] | null, readonly decl: FunctionDeclaration | null) { }\n}\n\nexport class GenericType {\n\treadonly kind = TypeVariants.GENERIC;\n\n\tconstructor(readonly name: string) { }\n}\n\nexport type Type = SimpleType | ArrayType | ReferenceType | HeterogenousArrayType | FunctionType | NoneType | UnknownType | GenericType;\n\nexport const [NUMBER, LOGIC, STRING, NONE, UNKNOWN] = [\n\tnew SimpleType(BaseType.NUMBER),\n\tnew SimpleType(BaseType.LOGIC),\n\tnew SimpleType(BaseType.STRING),\n\tnew NoneType(),\n\tnew UnknownType()\n]\n", "import { GenericType, LOGIC, NUMBER, STRING, SimpleType } from \"./types.ts\";\nimport { IToken } from \"./ITokenizer.ts\";\n\nexport function stringToBaseType(type: string): SimpleType | GenericType {\n\tswitch (type) {\n\t\tcase \"eg\u00E9sz\": return NUMBER\n\t\tcase \"sz\u00F6veg\": return STRING\n\t\tcase \"logikai\": return LOGIC\n\t}\n\n\t// For stuff like Function(x : T)\n\tif (type.length === 1 && type >= 'A' && type <= 'Z') return new GenericType(type)\n\n\tthrow new Error(`Expected type, got ${type}.`)\n}\n\nexport enum ASTTag {\n\tARRAYCOMP,\n\tARRINDEX,\n\tASSIGN,\n\tATOM,\n\tBINOP,\n\tBLOCK,\n\tDEBUG,\n\tFOR,\n\tFUNCCALL,\n\tFUNCDECL,\n\tIF,\n\tNEWARRAY,\n\tNOT,\n\tPARAMETER,\n\tPRINT,\n\tREFERENCE,\n\tRETURN,\n\tSWAP,\n\tVARIABLE,\n\tWHILE,\n}\n\ntype ASTBase<Tag extends ASTTag, Fields> = { tag: Tag, token: IToken | null } & Readonly<Fields>;\n\nexport type AtomValue = number | string | boolean;\n\nexport type Atom = ASTBase<ASTTag.ATOM, {\n\tvalue: AtomValue;\n\ttype: SimpleType\n}>\n\nexport type Debug = ASTBase<ASTTag.DEBUG, { msg?: string }>\n\nexport enum BinOpType {\n\tADD = 0,\n\tSUB = 1,\n\tMUL = 2,\n\tDIV = 3,\n\tMOD = 4,\n\n\tEQ = 5,\n\tNEQ = 6,\n\n\tLE = 7,\n\tGE = 8,\n\n\tLESS = 9,\n\tMORE = 10,\n\n\tAND = 11,\n\tOR = 12,\n}\n\nexport const BinOpTypeMap = new Map([\n\t[\"+\", BinOpType.ADD],\n\t[\"-\", BinOpType.SUB],\n\t[\"*\", BinOpType.MUL],\n\t[\"/\", BinOpType.DIV],\n\t[\"mod\", BinOpType.MOD],\n\t[\"=\", BinOpType.EQ],\n\t[\"=/=\", BinOpType.NEQ],\n\t[\"<=\", BinOpType.LE],\n\t[\">=\", BinOpType.GE],\n\t[\"<\", BinOpType.LESS],\n\t[\">\", BinOpType.MORE],\n\t[\"\u00E9s\", BinOpType.AND],\n\t[\"vagy\", BinOpType.OR],\n]);\n\nexport type BinaryOperation = ASTBase<ASTTag.BINOP, {\n\tlhs: Expression;\n\trhs: Expression;\n\top: BinOpType;\n}>\n\nexport type If = ASTBase<ASTTag.IF, {\n\tmain_path: { pred: Expression; branch: Block };\n\telif_path: Array<{ pred: Expression; branch: Block }>;\n\tfalse_path: Block | null;\n}>\n\nexport type Block = ASTBase<ASTTag.BLOCK, {\n\tstatements: Statement[];\n}>\n\nexport type Variable = ASTBase<ASTTag.VARIABLE, {\n\tname: string;\n}>\n\nexport type ArrayIndex = ASTBase<ASTTag.ARRINDEX, {\n\tvariable: Variable;\n\tindex: Expression[];\n}>\n\nexport type Reference = ASTBase<ASTTag.REFERENCE, {\n\tinner: Variable | ArrayIndex;\n}>\n\nexport type NewArray = ASTBase<ASTTag.NEWARRAY, {\n\ttype: SimpleType | GenericType;\n\tdimensions: Expression[];\n\tvariable: Variable\n}>\n\nexport type ArrayComprehension = ASTBase<ASTTag.ARRAYCOMP, {\n\tvariable: Variable;\n\texpressions: Array<Expression>;\n}>\n\nexport type Assignment = ASTBase<ASTTag.ASSIGN, {\n\tvariable: Variable | ArrayIndex;\n\tvalue: Expression;\n}>\n\nexport type For = ASTBase<ASTTag.FOR, {\n\tfrom: Expression;\n\tto: Expression;\n\tvariable: Variable;\n\tbody: Block;\n}>\n\nexport type While = ASTBase<ASTTag.WHILE, {\n\tpredicate: Expression;\n\tbody: Block;\n\tpostPred: boolean; // true -> do while\n}>\n\nexport type Not = ASTBase<ASTTag.NOT, {\n\texpr: Expression;\n}>\n\nexport type Print = ASTBase<ASTTag.PRINT, {\n\texpr: Expression;\n}>\n\nexport type Return = ASTBase<ASTTag.RETURN, {\n\texpr: Expression | Expression[];\n}>\n\nexport type FunctionCall = ASTBase<ASTTag.FUNCCALL, {\n\tname: string;\n\targuments: (Expression | IToken)[];\n}>\n\nexport type FunctionDeclaration = ASTBase<ASTTag.FUNCDECL, {\n\tname: string;\n\tparameters: Parameter[];\n\tbody: Block;\n}>\n\nexport type Parameter = ASTBase<ASTTag.PARAMETER, {\n\tname: Variable | string; // string = funcname\n\ttype: SimpleType | GenericType;\n\tbyRef: boolean;\n\tisArr: boolean;\n}>\n\nexport type Swap = ASTBase<ASTTag.SWAP, {\n\tvar1: Variable | ArrayIndex,\n\tvar2: Variable | ArrayIndex\n}>\n\nexport type Expression =\n\t| ArrayIndex\n\t| Atom\n\t| BinaryOperation\n\t| FunctionCall\n\t| Not\n\t| Reference\n\t| Variable\n\nexport type Statement =\n\t| ArrayComprehension\n\t| Assignment\n\t| Block\n\t| Debug\n\t| For\n\t| FunctionCall\n\t| FunctionDeclaration\n\t| If\n\t| NewArray\n\t| Print\n\t| Return\n\t| Swap\n\t| While;\n\nexport type ASTKind = Expression | Statement | Parameter;\n", "import { ASTKind, ASTTag, BinOpType } from \"../interfaces/astkinds.ts\";\nimport { ArrayType, BaseType, FunctionType, GenericType, HeterogenousArrayType, LOGIC, NONE, NUMBER, NoneType, ReferenceType, STRING, SimpleType, Type, TypeCheckError, TypeVariants, UnknownType } from \"../interfaces/types.ts\";\nimport { TypeMap } from \"./typemap.ts\";\n\nfunction compare(t1: Type, t2: Type): boolean {\n\tif (t1 instanceof NoneType && t2 instanceof NoneType) return true;\n\tif (t1 instanceof UnknownType && t2 instanceof UnknownType) return true;\n\n\tif (t1 instanceof SimpleType && t2 instanceof SimpleType) return t1.t === t2.t;\n\tif (t1 instanceof ArrayType && t2 instanceof ArrayType) return compare(t1.t, t2.t);\n\tif (t1 instanceof ReferenceType && t2 instanceof ReferenceType) return compare(t1.t, t2.t);\n\n\tif (t1 instanceof HeterogenousArrayType && t2 instanceof HeterogenousArrayType) {\n\t\treturn t1.ts.every((t, idx) => compare(t, t2.ts[idx]));\n\t}\n\n\tif (t1 instanceof FunctionType && t2 instanceof FunctionType) {\n\t\tconst rTypeMatches = compare(t1.rType, t2.rType)\n\t\tconst bothNull = t1.argTypes === null && t2.argTypes === null\n\n\t\tif (bothNull) {\n\t\t\treturn rTypeMatches\n\t\t} else {\n\t\t\tif (t1.argTypes === null || t2.argTypes === null) return false;\n\t\t\treturn t1.argTypes.every((t, idx) => compare(t, t2.argTypes![idx]));\n\t\t}\n\t}\n\n\tif (t1 instanceof GenericType && t2 instanceof GenericType) {\n\t\treturn t1.name === t2.name\n\t}\n\n\treturn false;\n}\n\nfunction show(t: Type): string {\n\tif (t instanceof SimpleType) {\n\t\tswitch (t.t) {\n\t\t\tcase BaseType.NUMBER:\n\t\t\t\treturn \"NUMBER\";\n\t\t\tcase BaseType.STRING:\n\t\t\t\treturn \"STRING\";\n\t\t\tcase BaseType.LOGIC:\n\t\t\t\treturn \"LOGIC\";\n\t\t}\n\t}\n\n\tif (t instanceof ArrayType) {\n\t\treturn `${show(t.t)} ARRAY`;\n\t}\n\n\tif (t instanceof ReferenceType) {\n\t\treturn `${show(t.t)} REFERENCE`;\n\t}\n\n\tif (t instanceof NoneType) return \"NONE\";\n\tif (t instanceof UnknownType) return \"UNKNOWN\";\n\n\tif (t instanceof HeterogenousArrayType) return `[${t.ts.map((type) => show(type))}]`;\n\n\tif (t instanceof FunctionType) return t.argTypes ? `FN(${t.argTypes.map(t => show(t))}) => ${show(t.rType)}` : `FN(?) => ${show(t.rType)}`\n\tif (t instanceof GenericType) return t.name\n\n\tthrow new Error(`Show: Should not happen.`);\n}\n\n\nexport function typeCheck(ast: ASTKind, env: TypeMap): [Type, TypeMap] {\n\tfunction ensure(ast: ASTKind, expected: Type): Type {\n\t\tconst actual = typeCheck(ast, env)[0];\n\n\t\t// TEMP FIXME\n\t\tif (actual instanceof GenericType) return actual;\n\n\t\tif (!compare(actual, expected))\n\t\t\tthrow new TypeCheckError(`Expected ${show(expected)}, got ${show(actual)}`, ast.token);\n\n\t\treturn actual;\n\t}\n\n\tswitch (ast.tag) {\n\t\tcase ASTTag.ARRINDEX: {\n\t\t\tast.index.forEach(e => ensure(e, NUMBER))\n\t\t\tconst variable = env.get(ast.variable.name)\n\n\t\t\tif (variable.kind === TypeVariants.ARRAY) {\n\t\t\t\treturn [variable.t, env]\n\t\t\t} else if (variable.kind === TypeVariants.HETEROGENOUS) {\n\t\t\t\treturn [new UnknownType(), env]\n\t\t\t}\n\n\t\t\tthrow new Error(`Expected ${ast.variable.name} to be T ARRAY, got ${show(variable)}.`)\n\t\t}\n\n\t\tcase ASTTag.ATOM: {\n\t\t\tif (typeof ast.value === \"number\") return [NUMBER, env];\n\t\t\tif (typeof ast.value === \"boolean\") return [LOGIC, env];\n\t\t\tif (typeof ast.value === \"string\") return [STRING, env];\n\t\t\tthrow new Error(`Expected number|string|boolean, got ${typeof ast.value}`);\n\t\t}\n\n\t\tcase ASTTag.BINOP: {\n\t\t\tconst { lhs, rhs } = ast;\n\n\t\t\tfunction eqOrThrow(a1: ASTKind, a2: ASTKind) {\n\t\t\t\tconst t1 = typeCheck(a1, env)[0];\n\t\t\t\tconst t2 = typeCheck(a2, env)[0];\n\n\t\t\t\tif (!compare(t1, t2)) {\n\t\t\t\t\tthrow new Error(`Expected both sides to be ${show(t1)}, but right side was ${show(t2)}`)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tswitch (ast.op) {\n\t\t\t\t// Arithmetics\n\t\t\t\tcase BinOpType.ADD:\n\t\t\t\tcase BinOpType.SUB:\n\t\t\t\tcase BinOpType.MUL:\n\t\t\t\tcase BinOpType.DIV:\n\t\t\t\tcase BinOpType.MOD:\n\t\t\t\t\tensure(lhs, NUMBER) && ensure(rhs, NUMBER)\n\t\t\t\t\treturn [NUMBER, env]\n\n\t\t\t\t// Comparison\n\t\t\t\tcase BinOpType.EQ:\n\t\t\t\tcase BinOpType.GE:\n\t\t\t\tcase BinOpType.LE:\n\t\t\t\tcase BinOpType.NEQ:\n\t\t\t\tcase BinOpType.MORE:\n\t\t\t\tcase BinOpType.LESS:\n\t\t\t\t\teqOrThrow(lhs, rhs);\n\t\t\t\t\treturn [LOGIC, env]\n\n\t\t\t\t// Logic\n\t\t\t\tcase BinOpType.AND:\n\t\t\t\tcase BinOpType.OR:\n\t\t\t\t\tensure(lhs, LOGIC) && ensure(rhs, LOGIC)\n\t\t\t\t\treturn [LOGIC, env]\n\t\t\t}\n\t\t}\n\n\t\tcase ASTTag.NOT: {\n\t\t\tensure(ast.expr, LOGIC)\n\t\t\treturn [LOGIC, env]\n\t\t}\n\n\t\tcase ASTTag.REFERENCE: {\n\t\t\treturn [new ReferenceType(typeCheck(ast.inner, env)[0]), env]\n\t\t}\n\n\t\tcase ASTTag.VARIABLE: {\n\t\t\treturn [env.get(ast.name), env]\n\t\t}\n\n\t\tcase ASTTag.ARRAYCOMP: {\n\t\t\tconst types = ast.expressions.map(e => typeCheck(e, env)[0]);\n\t\t\tconst same = types.every(t => compare(t, types[0]))\n\n\t\t\tif (same) {\n\t\t\t\treturn [NONE, env.with(ast.variable.name, new ArrayType(types[0]))]\n\t\t\t} else {\n\t\t\t\treturn [NONE, env.with(ast.variable.name, new HeterogenousArrayType(types))]\n\t\t\t}\n\t\t}\n\n\t\tcase ASTTag.ASSIGN: {\n\t\t\tconst valueType = typeCheck(ast.value, env)[0]\n\n\t\t\tif (ast.variable.tag === ASTTag.ARRINDEX) {\n\t\t\t\tconst variable = env.get(ast.variable.variable.name)\n\t\t\t\tif (variable.kind === TypeVariants.ARRAY) {\n\t\t\t\t\tif (!compare(variable.t, valueType)) {\n\t\t\t\t\t\tthrow new Error(`Expected ${show(valueType)} ARRAY, got ${show(variable)}`)\n\t\t\t\t\t}\n\n\t\t\t\t\tast.variable.index.forEach(e => ensure(e, NUMBER))\n\t\t\t\t\treturn [NONE, env]\n\t\t\t\t} else if (variable.kind === TypeVariants.HETEROGENOUS) {\n\t\t\t\t\tast.variable.index.forEach(e => ensure(e, NUMBER))\n\t\t\t\t\treturn [NONE, env]\n\t\t\t\t} else {\n\t\t\t\t\tthrow new Error(`Expected ${show(valueType)} ARRAY, got ${show(variable)}`)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn [NONE, env.with(ast.variable.name, typeCheck(ast.value, env)[0])]\n\t\t\t}\n\t\t}\n\n\t\tcase ASTTag.BLOCK: {\n\t\t\tconst wantToPush = (ast: ASTKind) => [ASTTag.IF, ASTTag.FOR, ASTTag.RETURN, ASTTag.WHILE].some(t => ast.tag === t)\n\n\t\t\tconst state = ast.statements.reduce<{ types: Type[], env: TypeMap }>(\n\t\t\t\t(state, statement) => {\n\t\t\t\t\tconst step = typeCheck(statement, state.env);\n\t\t\t\t\treturn { types: wantToPush(statement) ? state.types.concat(step[0]) : state.types, env: step[1] }\n\t\t\t\t}, { types: [], env })\n\n\t\t\tconst types = state.types.filter(t => !compare(t, NONE))\n\t\t\tif (types.length === 0) return [NONE, state.env]\n\t\t\tif (types.length === 1) return [types[0], state.env]\n\n\n\t\t\treturn [new HeterogenousArrayType(types), state.env]\n\t\t}\n\n\t\tcase ASTTag.DEBUG: {\n\t\t\treturn [NONE, env]\n\t\t}\n\n\t\tcase ASTTag.FOR: {\n\t\t\tensure(ast.from, NUMBER)\n\t\t\tensure(ast.to, NUMBER)\n\n\t\t\treturn typeCheck(ast.body, env.with(ast.variable.name, NUMBER))\n\t\t}\n\n\t\tcase ASTTag.FUNCDECL: {\n\t\t\tconst types = ast.parameters.map(t => typeCheck(t, env)[0])\n\t\t\tconst nEnv = types.reduce<TypeMap>((state, t, idx) => {\n\t\t\t\tconst arg = ast.parameters[idx].name\n\t\t\t\tconst name = (typeof arg === \"string\") ? arg : arg.name\n\t\t\t\tconst inner = (t instanceof ReferenceType) ? t.t : t;\n\n\t\t\t\treturn state.with(name, inner)\n\t\t\t}, env).with(ast.name, new FunctionType(NUMBER, null, null))\n\n\t\t\tconst type = typeCheck(ast.body, nEnv)[0]\n\t\t\treturn [NONE, env.with(ast.name, new FunctionType(type, types, ast))]\n\t\t}\n\n\t\tcase ASTTag.FUNCCALL: {\n\t\t\tconst func = env.get(ast.name);\n\t\t\tif (!(func instanceof FunctionType)) throw new Error(\"nonfunc\");\n\n\t\t\t// argTypes is null if we don't yet know how many / what type of args we have.\n\t\t\t// For instance:\n\t\t\t//\n\t\t\t// f\u00FCggv\u00E9ny A(Bels\u0151 : eg\u00E9sz)\n\t\t\t//  vissza Bels\u0151(5)\n\t\t\t// f\u00FCggv\u00E9ny v\u00E9ge\n\t\t\t//\n\t\t\t// We know Bels\u0151 has returntype number, but not what args it takes.\n\t\t\tconst at = func.argTypes;\n\t\t\tif (at === null) {\n\t\t\t\treturn [func.rType, env];\n\t\t\t}\n\n\t\t\tif (func.decl === null) {\n\t\t\t\tthrow new Error(\"Nodef\")\n\t\t\t}\n\n\t\t\tif (at.length != ast.arguments.length) throw new Error(\"len\")\n\n\t\t\t// Arguments arrive in reverse order, so we need to do a copy and reverse before we can compare the types.\n\t\t\tconst nEnv = [...ast.arguments].reverse().reduce<TypeMap>((state, arg, idx) => {\n\t\t\t\tconst type = (\"lexeme\" in arg) ? env.get(arg.lexeme) : typeCheck(arg, env)[0]\n\t\t\t\tconst name = (\"lexeme\" in arg) ? arg.lexeme : arg.token!.lexeme;\n\t\t\t\tconst expected = at[idx];\n\n\t\t\t\tif (expected instanceof GenericType) {\n\t\t\t\t\treturn state.substitute(expected.name, type).with(name, type)\n\t\t\t\t} else {\n\t\t\t\t\tif (!compare(type, expected)) throw new Error(`Expected ${show(expected)}, got ${show(type)}.`)\n\t\t\t\t\treturn state.with(name, type)\n\t\t\t\t}\n\t\t\t}, env)\n\n\t\t\ttypeCheck(func.decl, nEnv)\n\t\t\treturn [func.rType, env]\n\t\t}\n\n\t\tcase ASTTag.PARAMETER: {\n\t\t\tconst isFunc = (typeof ast.name === \"string\")\n\t\t\tlet type: Type = ast.type\n\t\t\tif (ast.isArr) type = new ArrayType(type);\n\t\t\tif (ast.byRef) type = new ReferenceType(type);\n\t\t\tif (isFunc) type = new FunctionType(type, null, null)\n\n\t\t\treturn [type, env]\n\t\t}\n\n\t\tcase ASTTag.IF: {\n\t\t\tensure(ast.main_path.pred, LOGIC)\n\t\t\tconst mainType = typeCheck(ast.main_path.branch, env)[0]\n\n\t\t\tconst elseType = ast.false_path ? typeCheck(ast.false_path, env)[0] : null\n\t\t\tconst elifTypes = ast.elif_path.map(p => (ensure(p.pred, LOGIC), typeCheck(p.branch, env)[0]))\n\n\t\t\tif (elseType && !compare(mainType, elseType)) {\n\t\t\t\tthrow new Error(`If has type ${show(mainType)}, but else has ${show(elseType)}.`)\n\t\t\t}\n\n\t\t\telifTypes.forEach((t, idx) => {\n\t\t\t\tif (!compare(mainType, t)) {\n\t\t\t\t\tthrow new Error(`If has type ${show(mainType)}, but the ${idx + 1}th else if has ${show(t)}.`)\n\t\t\t\t}\n\t\t\t})\n\n\t\t\treturn [mainType, env]\n\t\t}\n\n\t\tcase ASTTag.NEWARRAY: {\n\t\t\tast.dimensions.forEach(e => ensure(e, NUMBER))\n\n\t\t\treturn [NONE, env.with(ast.variable.name, new ArrayType(ast.type))]\n\t\t}\n\n\t\tcase ASTTag.PRINT: {\n\t\t\ttypeCheck(ast.expr, env)\n\t\t\treturn [NONE, env]\n\t\t}\n\n\t\tcase ASTTag.RETURN: {\n\t\t\tif (Array.isArray(ast.expr)) {\n\t\t\t\treturn [new HeterogenousArrayType(ast.expr.map(e => typeCheck(e, env)[0])), env]\n\t\t\t} else {\n\t\t\t\treturn typeCheck(ast.expr, env)\n\t\t\t}\n\t\t}\n\n\t\tcase ASTTag.SWAP: {\n\t\t\tconst t2 = typeCheck(ast.var2, env)[0]\n\t\t\tensure(ast.var1, t2)\n\n\t\t\treturn [NONE, env]\n\t\t}\n\n\t\tcase ASTTag.WHILE: {\n\t\t\tensure(ast.predicate, LOGIC)\n\t\t\treturn typeCheck(ast.body, env)\n\t\t}\n\t}\n}", "import { IToken, TokenType as TT, TokenType } from \"../interfaces/ITokenizer.ts\";\nimport { ASTKind } from \"../interfaces/astkinds.ts\";\nimport { Tokenizer } from \"./tokenizer.ts\";\n\n// Megmutatja, hogy egy adott input hanyadik elem\u00E9n\u00E9l j\u00E1runk.\ntype Input = { input: IToken[]; index: number };\n\n// Ha a keres\u00E9s sikeres, elt\u00E1roljuk a k\u00F6vetkez\u0151 keres\u00E9s hely\u00E9t \u00E9s az \u00E9rt\u00E9ket, melyet tal\u00E1ltunk.\n// Pl.: {input: \"asd\", index: 0}, keres\u00E9s c => c == 'a' eset\u00E9n: {type: \"match\", next: {input: \"asd\", index: 1}, value: \"a\"}\ntype Match<Output> = {\n\tvalue: Output;\n\tnext: Input;\n\ttype: \"match\";\n\textract(): Output\n};\n\n// Ha a keres\u00E9s sikertelen, akkor elt\u00E1roljuk annak ok\u00E1t \u00E9s a hib\u00E1s keres\u00E9s hely\u00E9t.\n// Pl.: {input: \"asd\", index: 0}, keres\u00E9s c => c == 'b' eset\u00E9n: {type: \"error\", location: {input: \"asd\", index: 0}, cause: \"Wanted 'b', found 'a'\"}\ntype ParsingError = {\n\ttype: \"error\";\n\tlocation: Input;\n\tcause: string;\n\textract(): never\n};\n\n// Egy keres\u00E9s eredm\u00E9nye vagy tal\u00E1lat vagy hiba.\ntype Result<Output> = Match<Output> | ParsingError;\n\n// Bin\u00E1ris m\u0171veletekn\u00E9l haszn\u00E1lt \"l\u00E1nc\". Egy bin\u00E1ris m\u0171velet a k\u00F6vektez\u0151 alakokat veheti fel:\n// - SZ\u00C1M (L)\n// - SZ\u00C1M M\u0170VELET SZ\u00C1M ({left: L, op: O, right: R})\n// - (SZ\u00C1M M\u0170VELET SZ\u00C1M) M\u0170VELET SZ\u00C1M {{left: Chain<L,O,R>, op: O, right: R}}\n// A legut\u00F3bbi sor tetsz\u0151leges m\u00E9lys\u00E9gig be\u00E1gyazhat\u00F3; a L\u00E1nc t\u00EDpus pont ezt a tulajdons\u00E1got fejezi ki. \nexport type Chain<L, O, R> = L | {\n\tleft: L | Chain<L, O, R>;\n\top: O;\n\tright: R;\n};\n\n/** Parser capable of parsing arbitrary values from a stream of IToken-s.\n * @template Output Output: The type of a successful match.\n */\nexport class Parser<Output> {\n\tconstructor(private exec: (inp: Input) => Result<Output>) { }\n\n\t/**\n\t * Executes the parser step-by-step, returning with either a ParsingError or a Match.\n\t * @param input An array of IToken-s.\n\t * @returns The result of executing all parsers associated to this chain.\n\t */\n\trun(input: IToken[]): Result<Output> {\n\t\treturn this.exec({ input, index: 0 });\n\t}\n\n\t// Kiveszi egy tokenstream els\u0151 elem\u00E9t \u00E9s visszat\u00E9r vele.\n\t// Ha a lista \u00FCres / v\u00E9g\u00E9re \u00E9rt\u00FCnk, hib\u00E1t dob.\n\tstatic item(): Parser<IToken> {\n\t\treturn new Parser((inp) =>\n\t\t\tinp.index >= inp.input.length\n\t\t\t\t? { type: \"error\", cause: \"EOF\", location: inp, extract: () => { throw new Error(\"Trying to extract from error.\") } }\n\t\t\t\t: {\n\t\t\t\t\ttype: \"match\",\n\t\t\t\t\tvalue: inp.input[inp.index],\n\t\t\t\t\tnext: { index: inp.index + 1, input: inp.input },\n\t\t\t\t\textract: () => inp.input[inp.index]\n\t\t\t\t},\n\t\t);\n\t}\n\n\t// An\u00E9lk\u00FCl, hogy tov\u00E1bbl\u00E9ptetn\u00E9 az inputot, visszat\u00E9r value-val.\n\tstatic result<O>(value: O): Parser<O> {\n\t\treturn new Parser((inp) => ({ type: \"match\", next: inp, value, extract: () => value }));\n\t}\n\n\t// Felt\u00E9tel n\u00E9lk\u00FCl hib\u00E1val t\u00E9r vissza, aminek a sz\u00F6veg\u00E9t mi adjuk.\n\tstatic fail(msg: string): Parser<never> {\n\t\treturn new Parser((inp) => ({ type: \"error\", cause: msg, location: inp, extract: () => { throw new Error(\"Trying to extract from error.\") } }));\n\t}\n\n\t// Ez a legfontosabb f\u00FCggv\u00E9ny az eg\u00E9sz oszt\u00E1lyban:\n\t// \u00DAgy k\u00E9pzeld el, hogy ha van k\u00E9t parser\u00FCnk A \u00E9s B, akkor a bind \"egym\u00E1sba l\u00E1ncolja \u0151ket,\" \u00FAgy, hogy az A v\u00E9grehajt\u00E1sa ut\u00E1ni \u00E9rt\u00E9k el\u00E9rhet\u0151v\u00E9 v\u00E1lik.\n\t// Pl.: Parser.item().bind(elso => Parser.item().bind(masodik => Parser.result(elso + masodik)))\n\t// Ekkor el\u0151sz\u00F6r v\u00E9grehajtuk az els\u0151 item()-et, majd a m\u00E1sodikat, v\u00E9g\u00FCl pedig a result (l\u00E1sd feljebb) seg\u00EDts\u00E9g\u00E9vel visszat\u00E9r\u00FCnk a kett\u0151 \u00F6sszeg\u00E9vel.\n\t// Fontos megjegyezni, hogy en\u00E9lk\u00FCl a f\u00FCggv\u00E9ny n\u00E9lk\u00FCl a parserb\u0151l nem tudunk \u00E9rt\u00E9ket kinyerni.\n\t// Hiba eset\u00E9n a futtat\u00E1s kor\u00E1n megszakad \u00E9s a hiba kipropag\u00E1l eg\u00E9szen a v\u00E9gs\u0151 h\u00EDv\u00E1sig ahol visszat\u00E9r\u00FCnk vele.\n\tbind<NewOutput>(other: (val: Output, input: Input) => Parser<NewOutput>): Parser<NewOutput> {\n\t\treturn new Parser((inp) => {\n\t\t\tconst current = this.exec(inp);\n\t\t\tif (current.type === \"error\") return current;\n\t\t\treturn other(current.value, inp).exec(current.next);\n\t\t});\n\t}\n\n\t// Ha van egy felfel\u00E9 propag\u00E1l\u00F3 hib\u00E1nk, a catch seg\u00EDts\u00E9g\u00E9vel elkaphatjuk azt \u00E9s m\u00F3dos\u00EDthatjuk.\n\t// Ez hasznos pl arra, ha egyedi hiba\u00FCzenettel szeretn\u00E9nk visszat\u00E9rni.\n\t// A many parser eset\u00E9n fogjuk el\u0151sz\u00F6r mag\u00E1t a hiba\u00FCzenetet \u00E9s mell\u00E9tessz\u00FCk, hogy egy\u00E9bk\u00E9nt t\u00F6bb ilyen elemet is v\u00E1rtunk.\n\tcatch(error: (previous: string) => string): Parser<Output> {\n\t\treturn new Parser((inp) => {\n\t\t\tconst current = this.exec(inp);\n\t\t\tif (current.type === \"error\")\n\t\t\t\treturn { type: \"error\", cause: error(current.cause), location: current.location, extract: () => { throw new Error(\"Trying to extract from error.\") } };\n\t\t\treturn current;\n\t\t});\n\t}\n\n\tstatic or<O, OO>(one: Parser<O>, other: Parser<OO>) {\n\t\treturn new Parser<O | OO>((inp) => {\n\t\t\tconst thisValue = one.exec(inp);\n\t\t\tif (thisValue.type === \"error\") {\n\t\t\t\tconst thatValue = other.exec(inp);\n\t\t\t\tif (thatValue.type === \"match\") return thatValue;\n\n\t\t\t\treturn this.fail(thisValue.cause + \" OR \" + thatValue.cause).exec(inp) //thisValue.location.index > thatValue.location.index ? thisValue : thatValue;\n\t\t\t}\n\t\t\treturn thisValue;\n\t\t});\n\t}\n\n\tstatic sat(\n\t\tpredicate: (val: IToken) => boolean,\n\t\tfailMsg = (val: IToken, input: Input) => \"Parsing error.\",\n\t): Parser<IToken> {\n\t\treturn Parser.item().bind((elem: IToken, inp) =>\n\t\t\tpredicate(elem) ? Parser.result<IToken>(elem) : Parser.fail(failMsg(elem, inp)),\n\t\t);\n\t}\n\n\tstatic many<O>(p: Parser<O>): Parser<O[]> {\n\t\treturn Parser.many1(p).or(Parser.result<O[]>([] as O[]));\n\t}\n\n\tstatic many1<O>(p: Parser<O>): Parser<O[]> {\n\t\treturn p\n\t\t\t.bind((first) => Parser.many(p).bind((rest) => Parser.result([first, ...rest])))\n\t\t\t.catch((p) => `Multiple(${p})`);\n\t}\n\n\tstatic sepBy<O>(parser: Parser<O>, separator: Parser<unknown>): Parser<O[]> {\n\t\treturn Parser.sepBy1(parser, separator).or(Parser.result([]));\n\t}\n\n\tstatic sepBy1<O>(parser: Parser<O>, separator: Parser<unknown>): Parser<O[]> {\n\t\treturn parser\n\t\t\t.bind((first) =>\n\t\t\t\tParser.many(separator.bind((_) => parser.bind((val) => Parser.result(val)))).bind((rest) =>\n\t\t\t\t\tthis.result([first, ...rest]),\n\t\t\t\t),\n\t\t\t)\n\t\t\t.catch((prev) => `${prev}, sep. by ${separator}`);\n\t}\n\n\tstatic chainl<Term, Operator, BaseCase>(\n\t\tterm: Parser<Term>,\n\t\top: Parser<Operator>,\n\t\tbaseCase: Parser<BaseCase>,\n\t) {\n\t\treturn Parser.chain(term, op).or(baseCase);\n\t}\n\n\tstatic chain<Term, Operator>(term: Parser<Term>, opParser: Parser<Operator>) {\n\t\tconst rest = <T>(a: T): Parser<T | Chain<T, Operator, Term>> =>\n\t\t\topParser\n\t\t\t\t.bind((op) => term.bind((right) => rest({ left: a, op, right })))\n\t\t\t\t.or(Parser.result(a));\n\t\treturn term.bind((left) => rest(left));\n\t}\n\n\t// BINDINGS\n\t// Here the static methods are bound to class objects. This allows chaining them.\n\t// i.e. Parser.item().many() instead of Parser.many(Parser.item())\n\t// This helps readability, imagine 5 levels of nesting from left to right.\n\n\tor<OtherOutput>(other: Parser<OtherOutput>) {\n\t\treturn Parser.or(this, other);\n\t}\n\n\tmany(): Parser<Output[]> {\n\t\treturn Parser.many<Output>(this);\n\t}\n\n\tmany1(): Parser<Output[]> {\n\t\treturn Parser.many1<Output>(this);\n\t}\n\n\tsepBy(separator: Parser<unknown>): Parser<Output[]> {\n\t\treturn Parser.sepBy<Output>(this, separator);\n\t}\n\n\tsepBy1(separator: Parser<unknown>): Parser<Output[]> {\n\t\treturn Parser.sepBy1<Output>(this, separator);\n\t}\n\n\tchainl<Operator, BaseCase>(op: Parser<Operator>, baseCase: Parser<BaseCase>) {\n\t\treturn Parser.chainl<IToken, Operator, BaseCase>(this, op, baseCase);\n\t}\n\n\t// EXTRAS\n\t// Things not described by the original paper, but that make parsing easier.\n\n\t// Basically the same as item(), but doesn't move the index forwards.\n\tstatic peek(n: number): Parser<IToken> {\n\t\treturn new Parser((inp) => {\n\t\t\treturn inp.index + n >= inp.input.length\n\t\t\t\t? { type: \"error\", cause: \"EOF\", location: inp, extract: () => { throw new Error(\"Trying to extract from error.\") } }\n\t\t\t\t: {\n\t\t\t\t\ttype: \"match\",\n\t\t\t\t\tvalue: inp.input[inp.index + n],\n\t\t\t\t\tnext: inp,\n\t\t\t\t\textract: () => inp.input[inp.index + n]\n\t\t\t\t};\n\t\t});\n\t}\n\n\tstatic mapChoice<Input, Output>(\n\t\tinput: Parser<Input>,\n\t\tmap: ReadonlyMap<Input, Parser<Output>>,\n\t): Parser<Output> {\n\t\treturn input.bind((elem, _) => {\n\t\t\tconst parser = map.get(elem);\n\n\t\t\tif (!parser) return Parser.fail(`No parser for ${elem}!`);\n\t\t\treturn parser;\n\t\t});\n\t}\n\n\t// Output here is the current parser's output, which is the map's Input!\n\tmapChoice<T>(map: ReadonlyMap<Output, Parser<T>>): Parser<T> {\n\t\treturn Parser.mapChoice(this, map);\n\t}\n\n\tstatic choice<T>(parsers: Parser<T>[]): Parser<T> {\n\t\tconst [first, ...rest] = parsers;\n\n\t\treturn rest.reduce((acc, curr) => acc.or(curr), first);\n\t}\n\n\tmap<T>(fn: (value: Output) => T): Parser<T> {\n\t\treturn this.bind((value) => Parser.result(fn(value)));\n\t}\n\n\tleft(other: Parser<unknown>): Parser<Output> {\n\t\treturn this.bind((value) => other.map((_) => value));\n\t}\n\n\tright<Other>(other: Parser<Other>): Parser<Other> {\n\t\treturn this.bind((_) => other.map((oValue) => oValue));\n\t}\n\n\tmaybe(): Parser<Output | null> {\n\t\treturn this.or(Parser.result(null));\n\t}\n\n\tstatic matchT(type: TT): Parser<IToken> {\n\t\treturn Parser.sat(\n\t\t\t(elem) => elem.type === type,\n\t\t\t(elem, input) =>\n\t\t\t\t`${input.index} - ${input.input[input.index].lexeme}: Expected type \"${TT[type]}\", got \"${TT[elem.type]\n\t\t\t\t}\".`,\n\t\t);\n\t}\n\n\tstatic of<T>(fn: () => Parser<T>): Parser<T> {\n\t\treturn new Parser((inp) => fn().exec(inp));\n\t}\n\n\tend() {\n\t\treturn this.left(Parser.matchT(TT.VEGE)).catch((prev) => `${prev} V\u00C9GE`);\n\t}\n\n\tparens() {\n\t\tconst oparen = Parser.matchT(TT.OPAREN);\n\t\tconst cparen = Parser.matchT(TT.CPAREN);\n\t\treturn oparen.right(this).left(cparen);\n\t}\n\n\tbrackets() {\n\t\tconst oparen = Parser.matchT(TT.OBRACKET);\n\t\tconst cparen = Parser.matchT(TT.CBRACKET);\n\t\treturn oparen.right(this).left(cparen);\n\t}\n\n\tstatic do() {\n\t\treturn new Do([]);\n\t}\n}\n\nclass Do<Bindings extends Record<string, unknown> = {}> {\n\tconstructor(private bindList: Array<{ name: string | null; parser: Parser<unknown> }>) { }\n\n\tbind<N extends string, T>(name: N, parser: Parser<T>): Do<Bindings & Record<N, T>> {\n\t\treturn new Do([...this.bindList, { name, parser }]);\n\t}\n\n\tignore(parser: Parser<unknown>): Do<Bindings> {\n\t\treturn new Do([...this.bindList, { name: null, parser }]);\n\t}\n\n\tbindT<N extends string>(name: N, type: TT): Do<Bindings & Record<N, IToken>> {\n\t\treturn new Do([...this.bindList, { name, parser: Parser.matchT(type) }]);\n\t}\n\n\tignoreT(type: TT): Do<Bindings> {\n\t\treturn new Do([...this.bindList, { name: null, parser: Parser.matchT(type) }]);\n\t}\n\n\tmaybeT<N extends string>(name: N, type: TT): Do<Bindings & Record<N, IToken | null>> {\n\t\treturn new Do([...this.bindList, { name, parser: Parser.matchT(type).maybe() }]);\n\t}\n\n\tfinalize<T extends Record<string, unknown>>(given: T): Parser<Bindings & T> {\n\t\tfunction recursion(\n\t\t\tparsers: Do[\"bindList\"],\n\t\t\tobj: Record<string, unknown>,\n\t\t): Parser<Bindings & T> {\n\t\t\tif (parsers.length === 0) return Parser.result(obj) as Parser<Bindings & T>;\n\n\t\t\tconst { name, parser } = parsers[0];\n\n\t\t\treturn parser.bind((value) => {\n\t\t\t\tconst newObj = { ...obj };\n\t\t\t\tif (name) newObj[name] = value;\n\t\t\t\treturn recursion(parsers.slice(1), newObj);\n\t\t\t});\n\t\t}\n\n\t\treturn recursion(this.bindList, given);\n\t}\n\n\tresult<T>(fn: (val: Bindings) => T) {\n\t\treturn this.finalize({}).map(fn);\n\t}\n}\n\nexport type P<T> = Parser<T>;\nexport { TokenType as TT };\n\nexport const mkToken = <T extends ASTKind>(\n\ttoken: T[\"token\"],\n\ttag: T[\"tag\"],\n\trest: Omit<T, \"token\" | \"tag\">,\n): T =>\n\t({\n\t\ttoken,\n\t\ttag,\n\t\t...rest,\n\t}) as unknown as T;\n\nexport const t = (inp: string) => new Tokenizer().tokenize(inp).filter(token => token.type !== TT.WHITESPACE);\n", "import { IToken } from \"../interfaces/ITokenizer.ts\";\nimport {\n\tASTTag,\n\tArrayComprehension,\n\tArrayIndex,\n\tAssignment,\n\tAtom,\n\tBinOpTypeMap,\n\tBinaryOperation,\n\tBlock,\n\tDebug,\n\tExpression,\n\tFor,\n\tFunctionCall,\n\tFunctionDeclaration,\n\tIf,\n\tNewArray,\n\tNot,\n\tParameter,\n\tPrint,\n\tReference,\n\tReturn,\n\tStatement,\n\tSwap,\n\tVariable,\n\tWhile,\n\tstringToBaseType,\n} from \"../interfaces/astkinds.ts\";\nimport { GenericType, LOGIC, NUMBER, STRING, SimpleType } from \"../interfaces/types.ts\";\nimport { Chain, P, Parser, TT, mkToken } from \"./monadic_parser_base.ts\";\n\nconst parseBaseType: P<SimpleType | GenericType> = Parser.matchT(TT.TYPE).map(t => stringToBaseType(t.lexeme))\n\nconst parseStatement: P<Statement> = Parser.of<Statement>(\n\t() => {\n\t\tconst symbolParser = Parser.choice([\n\t\t\tparseSwap as Parser<Statement>,\n\t\t\tparseAssignment,\n\t\t\tparseNewArray,\n\t\t\tparseComprehension\n\t\t])\n\n\t\tconst statementMap: ReadonlyMap<TT, Parser<Statement>> = new Map([\n\t\t\t[TT.HA, parseIf as Parser<Statement>],\n\t\t\t[TT.VISSZA, parseReturn],\n\t\t\t[TT.CIKLUS, parseFor.or(parseWhile)],\n\t\t\t[TT.SYMBOL, symbolParser],\n\t\t\t[TT.FUGGVENY, parseFuncDecl],\n\t\t\t[TT.KIIR, parsePrint],\n\t\t\t[TT.DEBUG, parseDebug],\n\t\t\t[TT.FUNCNAME, parseFuncCall],\n\t\t]);\n\n\t\treturn Parser.peek(0)\n\t\t\t.map((t) => t.type)\n\t\t\t.mapChoice(statementMap);\n\t},\n\t//.or(parseExpression), Ha t\u00E1mogatni akarjuk a l\u00F3g\u00F3 expression\u00F6ket.\n);\n\nexport const parseExpression: P<Expression> = Parser.of(() =>\n\tparseBinOp\n);\n\nexport const parseBlock: P<Block> = parseStatement\n\t.many1()\n\t.map((stmts) => mkToken(null, ASTTag.BLOCK, { statements: stmts }));\n\nconst parseVariable: P<Variable> = Parser.matchT(TT.SYMBOL).map((token) =>\n\tmkToken(token, ASTTag.VARIABLE, { name: token.lexeme }),\n);\n\nconst parseComprehension: P<ArrayComprehension> = Parser.do()\n\t.bind(\"variable\", parseVariable)\n\t.ignoreT(TT.NYIL)\n\t.bind(\"expressions\",\n\t\tparseExpression\n\t\t\t.sepBy(Parser.matchT(TT.COMMA))\n\t\t\t.parens())\n\t.result(({ variable, expressions }) => mkToken(null, ASTTag.ARRAYCOMP, { variable, expressions }));\n\nconst parseArrayIndex: P<ArrayIndex> = Parser.do()\n\t.bind(\"variable\", parseVariable)\n\t.bind(\"index\", parseExpression.sepBy1(Parser.matchT(TT.COMMA)).brackets())\n\t.result(({ variable, index }) => mkToken(variable.token, ASTTag.ARRINDEX, { variable, index }));\n\n// New Array\n\nconst parseNewMultiDimArray: P<NewArray> = Parser.do()\n\t.bind(\"variable\", parseVariable)\n\t.ignoreT(TT.NYIL)\n\t.bindT(\"token\", TT.TABLALETREHOZ)\n\t.bind(\"type\", parseBaseType.parens())\n\t.bind(\"dimensions\", parseExpression.sepBy1(Parser.matchT(TT.COMMA)).brackets())\n\t.result(({ variable, token, type, dimensions }) =>\n\t\tmkToken(token, ASTTag.NEWARRAY, { variable, dimensions, type }),\n\t);\n\nconst parseNewSingleDimArray: P<NewArray> = Parser.do()\n\t.bind(\"variable\", parseVariable)\n\t.ignoreT(TT.NYIL)\n\t.bindT(\"token\", TT.LETREHOZ)\n\t.bind(\"type\", parseBaseType.parens())\n\t.bind(\"length\", parseExpression.brackets())\n\t.result(({ variable, token, type, length }) =>\n\t\tmkToken(token, ASTTag.NEWARRAY, { variable, dimensions: [length], type }),\n\t);\n\nconst parseNewArray = parseNewSingleDimArray.or(parseNewMultiDimArray);\n\nconst parseSwap: P<Swap> = Parser.do()\n\t.bind(\"var1\", parseArrayIndex.or(parseVariable))\n\t.bindT(\"token\", TT.SWAP)\n\t.bind(\"var2\", parseArrayIndex.or(parseVariable))\n\t.result(({ var1, token, var2 }) => mkToken(token, ASTTag.SWAP, { var1, var2 }));\n\n//#region Atom\n\nconst number: P<Atom> = Parser.matchT(TT.NUMBER).map((token) =>\n\tmkToken(token, ASTTag.ATOM, { type: NUMBER, value: Number(token.lexeme) }),\n);\n\nconst boolean: P<Atom> = Parser.matchT(TT.BOOLEAN).map((token) =>\n\tmkToken(token, ASTTag.ATOM, { type: LOGIC, value: [\"Igaz\", \"igaz\"].includes(token.lexeme) }),\n);\n\nconst string: P<Atom> = Parser.matchT(TT.STRING).map((token) =>\n\tmkToken(token, ASTTag.ATOM, { type: STRING, value: token.lexeme }),\n);\n\nconst parseAtom = Parser.choice([number, boolean, string]);\n\n//#endregion\n\nconst parseNot: P<Not> = Parser.matchT(TT.NEGAL).bind((token) =>\n\tparseExpression.map((expr) => mkToken(token, ASTTag.NOT, { expr })),\n);\n\nconst parseReference: P<Reference> = Parser.matchT(TT.REFERENCE).bind((token) =>\n\tparseArrayIndex.or(parseVariable).map((inner) => mkToken(token, ASTTag.REFERENCE, { inner })),\n);\n\n//#region BinOp\n\nconst addOp = Parser.sat((tok) => [\"+\", \"-\"].includes(tok.lexeme));\nconst mulOp = Parser.sat((tok) => [\"*\", \"/\", \"mod\"].includes(tok.lexeme));\nconst compOp = Parser.sat((tok) => [\">\", \"<\", \"=\", \"<=\", \">=\", \"=/=\"].includes(tok.lexeme));\nconst logicOp = Parser.sat((tok) => [\"\u00E9s\", \"vagy\"].includes(tok.lexeme));\n\n// Because we're using a stack based VM, we need to reverse arguments, hence args.reverse()\nconst parseFuncCall: P<FunctionCall> = Parser.do()\n\t.bindT(\"name\", TT.FUNCNAME)\n\t.bind(\"args\", parseExpression.or(Parser.matchT(TT.FUNCNAME)).sepBy(Parser.matchT(TT.COMMA)).parens())\n\t.result(({ name, args }) => mkToken(name, ASTTag.FUNCCALL, { name: name.lexeme, arguments: args.reverse() }));\n\nconst primary: P<Expression> = Parser.choice([\n\tparseExpression.parens(),\n\tparseNot,\n\tparseReference,\n\tparseFuncCall,\n\tparseArrayIndex,\n\tparseVariable,\n\tparseAtom,\n]);\n\nconst chainToExpr = (chain: Expression | Chain<Expression, IToken, Expression>): Expression => {\n\t// Ez egy expression, t\u00E9rj\u00FCnk vissza vele ahogy van.\n\tif (!(\"left\" in chain)) {\n\t\treturn chain;\n\t}\n\n\tconst binop = BinOpTypeMap.get(chain.op.lexeme);\n\tif (binop === undefined) throw new Error(`Unknown binop: \"${chain.op.lexeme}\".`);\n\n\treturn mkToken<BinaryOperation>(chain.op, ASTTag.BINOP, {\n\t\tlhs: \"left\" in chain.left ? chainToExpr(chain.left) : chain.left,\n\t\top: binop,\n\t\trhs: chain.right,\n\t});\n};\n\nconst parseArithmOp: P<Expression> = Parser.chain(primary, addOp).map(chainToExpr);\nconst parseMulOp: P<Expression> = Parser.chain(parseArithmOp, mulOp).map(chainToExpr);\nconst parseCompOp: P<Expression> = Parser.chain(parseMulOp, compOp).map(chainToExpr);\nexport const parseBinOp: P<Expression> = Parser.chain(parseCompOp, logicOp).map(chainToExpr);\n\n//#endregion\n\nexport const parseAssignment: P<Assignment> = Parser.do()\n\t.bind(\"variable\", parseArrayIndex.or(parseVariable))\n\t.bindT(\"nyil\", TT.NYIL)\n\t.bind(\"value\", parseExpression)\n\t.result(({ variable, nyil, value }) =>\n\t\tmkToken(nyil, ASTTag.ASSIGN, {\n\t\t\tvariable,\n\t\t\tvalue,\n\t\t}),\n\t);\n\nconst parseDebug: P<Debug> = Parser.matchT(TT.DEBUG).map((token) => mkToken(token, ASTTag.DEBUG, {}));\n\nconst parseFor: P<For> = Parser.do()\n\t.bindT(\"token\", TT.CIKLUS)\n\t.bind(\"variable\", parseVariable)\n\t.ignoreT(TT.NYIL)\n\t.bind(\"from\", parseExpression)\n\t.ignoreT(TT.FORSTART)\n\t.bind(\"to\", parseExpression)\n\t.ignoreT(TT.FOREND)\n\t.bind(\"body\", parseBlock)\n\t.ignoreT(TT.CIKLUS)\n\t.ignoreT(TT.VEGE)\n\t.result(({ token, variable, from, to, body }) =>\n\t\tmkToken(token, ASTTag.FOR, {\n\t\t\tfrom,\n\t\t\tto,\n\t\t\tbody,\n\t\t\tvariable,\n\t\t}),\n\t);\n\n//#region Function Declaration\n\nconst parseByRef = Parser.matchT(TT.CIMSZERINT)\n\t.map((_) => true)\n\t.or(Parser.result(false));\n\nconst parseParamType = Parser.do()\n\t.bind(\"type\", parseBaseType)\n\t.maybeT(\"isSorted\", TT.RENDEZETT)\n\t.maybeT(\"isArray\", TT.TOMB)\n\t.finalize({});\n\nconst parseParameter: P<Parameter> = Parser.do()\n\t.bind(\"byRef\", parseByRef)\n\t.bind(\"name\", parseVariable.or(Parser.matchT(TT.FUNCNAME)))\n\t.ignoreT(TT.COLON)\n\t.bind(\"type\", parseParamType)\n\t.result(({ byRef, name, type }) =>\n\t\tmkToken(\"token\" in name ? name.token : name, ASTTag.PARAMETER, {\n\t\t\tbyRef,\n\t\t\tname: \"token\" in name ? name : name.lexeme,\n\t\t\ttype: type.type,\n\t\t\tisArr: type.isArray !== null\n\t\t}),\n\t);\n\nexport const parseFuncDecl: P<FunctionDeclaration> = Parser.do()\n\t.bindT(\"token\", TT.FUGGVENY)\n\t.bindT(\"name\", TT.FUNCNAME)\n\t.bind(\"parameters\", parseParameter.sepBy(Parser.matchT(TT.COMMA)).parens())\n\t.bind(\"body\", parseBlock)\n\t.ignoreT(TT.FUGGVENY)\n\t.ignoreT(TT.VEGE)\n\t.result(({ token, body, name, parameters }) =>\n\t\tmkToken(token, ASTTag.FUNCDECL, { body, name: name.lexeme, parameters }),\n\t);\n\n//#endregion\n\n//#region If\n\nconst parseIfHead = Parser.do()\n\t.bindT(\"token\", TT.HA)\n\t.bind(\"pred\", parseExpression)\n\t.ignoreT(TT.AKKOR)\n\t.bind(\"branch\", parseBlock)\n\t.finalize({});\n\nconst parseElse = Parser.matchT(TT.KULONBEN).right(parseBlock);\n\nconst parseElIf = Parser.matchT(TT.KULONBEN).right(parseIfHead);\n\nconst parseIf: P<If> = Parser.do()\n\t.bind(\"main_path\", parseIfHead)\n\t.bind(\"elif_path\", parseElIf.many())\n\t.bind(\"false_path\", parseElse.maybe())\n\t.ignoreT(TT.ELAGAZAS)\n\t.ignoreT(TT.VEGE)\n\t.result(({ main_path, elif_path, false_path }) =>\n\t\tmkToken(main_path.token, ASTTag.IF, { main_path, elif_path, false_path }),\n\t);\n\n//#endregion\n\nconst parsePrint: P<Print> = Parser.matchT(TT.KIIR).bind((token) =>\n\tparseExpression.map((expr) => mkToken(token, ASTTag.PRINT, { expr })),\n);\n\nconst comp =\n\tparseExpression\n\t\t.sepBy(Parser.matchT(TT.COMMA))\n\t\t.parens()\n\nconst parseReturn: P<Return> = Parser.matchT(TT.VISSZA).bind((token) =>\n\tParser.or(comp, parseExpression)\n\t\t.map((expr) => mkToken(token, ASTTag.RETURN, { expr })),\n);\n\n//#region While\n\nconst parseNormalWhile = Parser.do()\n\t.bindT(\"token\", TT.CIKLUS)\n\t.ignoreT(TT.AMIG)\n\t.bind(\"predicate\", parseExpression)\n\t.bind(\"body\", parseBlock)\n\t.ignoreT(TT.CIKLUS)\n\t.ignoreT(TT.VEGE)\n\t.finalize({ postPred: false });\n\nconst parseDoWhile = Parser.do()\n\t.bindT(\"token\", TT.CIKLUS)\n\t.bind(\"body\", parseBlock)\n\t.ignoreT(TT.AMIG)\n\t.bind(\"predicate\", parseExpression)\n\t.finalize({ postPred: true });\n\nexport const parseWhile: P<While> = parseDoWhile\n\t.or(parseNormalWhile)\n\t.map((value) => mkToken(value.token, ASTTag.WHILE, value));\n\n//#endregion\n", "import { GenericType, Type } from \"../interfaces/types.ts\";\n\n\ntype Binding = { name: string, type: Type }\nexport class TypeMap {\n\tconstructor(readonly types: Binding[], readonly substitutions: Binding[]) { }\n\n\twith(name: string, type: Type): TypeMap {\n\t\treturn new TypeMap([...this.types, { name, type }], this.substitutions);\n\t}\n\n\tsubstitute(name: string, type: Type): TypeMap {\n\t\treturn new TypeMap(this.types, [...this.substitutions, { name, type }]);\n\t}\n\n\tprivate find(name: string): Binding | undefined {\n\t\tconst first = this.types.find(t => t.name === name);\n\t\tif (!first) return undefined;\n\n\t\tif (first.type instanceof GenericType) {\n\t\t\treturn this.substitutions.find(t => t.name === (first.type as GenericType).name) ?? first\n\t\t}\n\n\t\treturn first\n\t}\n\n\t/*\nrealize(t: Type) {\n\tif (t instanceof GenericType) {\n\t\treturn this.substitutions.find(t => t.name === (first.type as GenericType).name) ?? first\n\t}\n}\n\t */\n\n\texists(name: string): boolean {\n\t\treturn this.find(name) !== undefined\n\t}\n\n\tget(name: string): Type {\n\t\tconst val = this.find(name)\n\t\tif (!val) throw new Error(`${name} has no binding.`)\n\n\t\treturn val.type\n\t}\n\n\tgetSubst(gt: GenericType): Type {\n\t\tconst type = this.substitutions.find(t => t.name === gt.name)?.type\n\t\t//if (!type) throw new Error(`${t.name} has no substitution.`)\n\n\t\treturn type ?? gt;\n\t}\n}\n", "import type { Programs } from \"./program_loader.ts\";\nimport { tokenize } from \"./token.ts\"\nimport { typeCheck } from \"../compiler/typecheck.ts\"\nimport { TokenType } from \"../interfaces/ITokenizer.js\";\nimport { parseBlock } from \"../parser/ast_parser.ts\"\nimport { TypeMap } from \"../compiler/typemap.ts\";\n\ntype HCResult = {type: \"chapter\", number: number} | {\n    type: \"entry\",\n    name: string,\n    tokenizes: boolean,\n    ast: boolean,\n    typechecks: boolean,\n    error: string | null\n}\n\nwindow.addEventListener(\"load\", () => {\n    const tbody = document.getElementById(\"algorithms\")! as HTMLTableSectionElement;\n    const counter = document.getElementById(\"counter\")! as HTMLParagraphElement;\n\n    fetch(\"./jegyzet.json\").then(r => r.json()).then((json: Programs) => {\n        const result = [] as HCResult[];\n\n        for (const elem in json) {\n            const collection = json[elem];\n\n            result.push({\n                type: \"chapter\",\n                number: Number(elem)\n            })\n\n            for (let idx = 0; idx < collection.length; idx++) {\n                const entry = collection[idx];\n                const tokens = tokenize(entry.code.join(\"\\n\"))[1]\n\n                const index = Number(elem) * 100 + idx\n                const name = entry.name\n\n                if (tokens.at(-1)?.type == TokenType.ERROR) {\n                    result.push({\n                        type: \"entry\",\n                        name,\n                        error: \"Tokenizer failed\",\n                        tokenizes: false,\n                        ast: false,\n                        typechecks: false\n                    })\n\n                    continue;\n                }\n\n                const match = parseBlock.run(tokens)\n\n                if (match.type == \"error\") {\n                    result.push({\n                        type: \"entry\",\n                        name,\n                        error: match.cause,\n                        tokenizes: true,\n                        ast: false,\n                        typechecks: false\n                    })\n\n                    continue;\n                }\n\n                try {\n                typeCheck(match.value, new TypeMap([],[]));\n\n                    result.push({\n                        type: \"entry\",\n                        name,\n                        error: null,\n                        tokenizes: true,\n                        ast: true,\n                        typechecks: true\n                    })\n\n                } catch(e) {\n                    if (!(e instanceof Error)) throw e;\n\n                    result.push({\n                        type: \"entry\",\n                        name,\n                        error: e.message,\n                        tokenizes: true,\n                        ast: true,\n                        typechecks: false\n                    })\n                }\n            }\n        }\n\n        return result\n    }).then(results => {\n        const rowToHTML = (row: HCResult) => {\n            if (row.type === \"entry\") {\n                return `<tr>\n                    <td class=\"name\">${row.name}</td>\n                    <td>${row.tokenizes ? \"\u2705\" : \"\u274C\"}</td>\n                    <td>${row.ast ? \"\u2705\" : \"\u274C\"}</td>\n                    <td>${row.typechecks ? \"\u2705\" : \"\u274C\"}</td>\n                    <td>${row.error ? row.error : \"\"}</td>\n                </tr>`\n            } else {\n                return `<tr><td colspan=5>${row.number}. Chapter</td></tr>`;\n            }\n        }\n\n        tbody.innerHTML = results.map(rowToHTML).join(\"\\n\")\n\n        counter.innerHTML = `${results.filter(r => r.type === \"entry\" && r.tokenizes && r.typechecks).length}/${results.filter(r => r.type === \"entry\").length} pass.`\n    })\n})"],
  "mappings": "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",
  "names": ["TokenType", "t", "ast", "eqOrThrow", "state", "p"]
}
